use std::comparator;

fn escalar_product(lhs: [Field; LEN], rhs: [Field; LEN]) -> Field {
    let mut lc = 0;
    for idx in 0..LEN {
        lc = lc + (lhs[idx] * rhs[idx]);
    }
    return lc;
}

fn selector(const LEN: Field, target_idx: Field) -> [Field; LEN] {
    let mut out = [0; LEN];
    let mut lc = 0;
    let one = 1;
    let zero = 0;

    for idx in 0..LEN {
        out[idx] = if idx == target_idx { one } else { zero };
        lc = lc + out[idx];
    }

    // for ensuring there is one chosen in the range of LEN
    assert(lc == 1);

    return out;
}

fn select_element(arr: [[Field; WIDLEN]; ARRLEN], target_idx: Field) -> [Field; WIDLEN] {
    let mut out = [0; WIDLEN];

    let selector_arr = selector(ARRLEN, target_idx);
    let mut one_len_arr = [0; ARRLEN];

    for idx in 0..WIDLEN {
        for jdx in 0..ARRLEN {
            one_len_arr[jdx] = arr[jdx][idx];
        }
        // there is only one element in the selector_arr that is 1
        // so the result is the element in one_len_arr that is at the same index as the 1 in selector_arr
        out[idx] = escalar_product(one_len_arr, selector_arr);

        // reset one_len_arr
        one_len_arr = [0; ARRLEN];
    }
    return out;
}