rd_("jA functionAkThe <code>if</code> keywordBiThe <code>in</code> keyword for iteratingAjContains the success valueAhContains the error valueAlThe <code>for</code> keywordlNew variableCbThe <code>mut</code> keyword for mutable variablesAg<code>!bool_expr</code>lPublic inputChA reference to a noname variable in the environment. \xe2\x80\xa6AcImporting a libraryfA Var.CjThe CellVar type for the backend. Different backend is \xe2\x80\xa6CgRepresents a variable in the noname language, or an \xe2\x80\xa6CeSame as crate::var::Var, but with Term instead of \xe2\x80\xa6ladd two varsAgAdds two field elementsB`Add an unbound generic parameterAbASM-like language:BdGet the value of a generic parameterCcMaps a filename id to its filename and source code.Aomultiply a var with another varAmMultiplies two field elementslnegate a varAgNegates a field elementAcCreates a new FnEnv0BhCreates a new [Error] from an ErrorKind.AeCreates a new TypeEnvCbCreates a new TypeEnv with the given function kindAeExits a scoped block.000CaYou can use this module for serialization and \xe2\x80\xa6lsub two varsCkSubtracts two variables, we only support variables that \xe2\x80\xa6CnWe keep track of the type of variables, eventhough we\xe2\x80\x99re \xe2\x80\xa6lType of gate1CiThe resolved type of the expression node. The generic \xe2\x80\xa6AfSome type information.0mThe variable.0Bg<code>true</code> or <code>false</code>CdA boolean (<code>true</code> or <code>false</code>).AnA cell in the execution trace.AmThe <code>else</code> keywordCjEither it\xe2\x80\x99s a hint and can be computed from the outside.oA hint functionClMast relies on the TAST for the information about the \xe2\x80\x9c\xe2\x80\xa6BbR1CS backend with bls12_381 field.CjThings you can have in a scope (including the root scope).BcThe boolean value <code>true</code>CnLike next() except that it also stores the last seen token \xe2\x80\xa6BeEvaluate symbolic size to an integer.BbThe monomorphized expression node.AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AbThe type of error.AfEnters a scoped block.000AlA note on why this was addedCiPeeks into the next token without advancing the iterator.BcThe span that created the variable.CkThe place in the original source code that created that \xe2\x80\xa6CeIndicate where the error occurred in the source code.BeThe span of the variable declaration.0BlThis is a type imported from another module.AiAn array of a fixed size.AaA constant value.AnAllows constants to be definedAcAn error in noname.BdThe boolean value <code>false</code>ChThe circuit field / scalar field that the circuit is \xe2\x80\xa6BeThe main primitive type. \xe2\x80\x99Nuf said.CgSame as [crate::fn_env::FnEnv], but with Term based \xe2\x80\xa6ChIs used to store functions\xe2\x80\x99 scoped variables. This \xe2\x80\xa6CmAny kind of text that can represent a type, a variable, a \xe2\x80\xa6CgThis is a local type, not imported from another module.CeA tuple is a data structure which contains many typesCnA variable\xe2\x80\x99s actual value in the witness can be computed \xe2\x80\xa6BjThe wiring (associated to different spans)AeThe type of variable.ClThis takes variables that can be anything, and returns a \xe2\x80\xa6CmA hint as to where the error happened (e.g. type-checker, \xe2\x80\xa6BbReturn all generic parameter namesCkParses until it finds something it doesn\xe2\x80\x99t know, then \xe2\x80\xa6BjParse from an expression node recursively.CfParse a function, without the <code>fn</code> keyword.CnReturns a list of statement parsed until seeing the end of \xe2\x80\xa6Bcreturns a proof and a public outputAkCustom / user-defined typesAf<code>lhs(args)</code>ChKeeps track of the signature of a user-defined function.BiThe different types of a noname function.B`The signature of a hint functionCnResulted IR term and the (name, variable) for arguments of \xe2\x80\xa6Bm<code>if cond { then_ } else { else_ }</code>B`Method defined on a custom type.CmA module that contains both built-in functions and native \xe2\x80\xa6BkA native function is represented as an AST.BaExtract the nth bit from a value.AfReturn from a functionCkA string type current purpose it to pass around for loggingBcAllows custom structs to be definedBeAttribute required for hint functionsCmDon\xe2\x80\x99t use this function unless you\xe2\x80\x99re testing, it\xe2\x80\x99s \xe2\x80\xa6BcBind a generic parameter to a valuelCoefficientsCnThis module defines the context (or environment) that gets \xe2\x80\xa6CeUsed to parse public and private inputs to a program.DgSet to <code>None</code> if the function is defined in the main module.ClThis is a high-level language to write circuits that you \xe2\x80\xa6ClPrint a field in a negative form if it\xe2\x80\x99s past the half \xe2\x80\xa6B`This module contains the prover.CkA number of helper function to check the syntax of some \xe2\x80\xa6CnSince std::iter::Peekable in Rust advances the iterator, I \xe2\x80\xa6kany numbersBoA module that contains only built-in functions.CnA built-in is just a handle to a function written in Rust. \xe2\x80\xa6AaGeneric parameterCkReturns the inverse of the given variable. Note that it \xe2\x80\xa6CmA context to store the last node id for the monomorphized \xe2\x80\xa6Ab<code>-expr</code>CmYou can use SerdeAs with serde_with in order to serialize \xe2\x80\xa6CfContains the association between a counter and the \xe2\x80\xa6CnSame as [crate::fn_env::VarInfo], but with Term based Var. \xe2\x80\xa6AmInformation about a variable.CkThis takes the AST produced by the parser, and performs \xe2\x80\xa6CiThe constraint backend for the circuit. For now, this \xe2\x80\xa6lCustom typesCbReturns the function info by fully qualified name.ClThis retrieves a dependency listed in the manifest file. \xe2\x80\xa6CkReturns true if the given string is a type Check camel caseBfIf the variable can be mutated or not.CnA counter used to uniquely identify different nodes in the \xe2\x80\xa6CaThe last node id for the MAST phase to reference.CeCustom structs type information and ASTs for methods.CnConvert an expression to another expression, with the same \xe2\x80\xa6C`This is a type imported from another module, \xe2\x80\xa6Ao<code>lhs &lt;op&gt; rhs</code>A`A literal numberDgOr it\xe2\x80\x99s a constant (for example, I wrote <code>2</code> in the code).AlPoint to a constant variableCjA public or private input to the function There\xe2\x80\x99s an \xe2\x80\xa6ChAn actual handle to the internal function to call to \xe2\x80\xa6iFunction.CjNot yet wired (just indicates the position of the cell \xe2\x80\xa6ClSome type information on local variables that we want to \xe2\x80\xa6CeA dependency is a Github <code>user/repo</code> pair.CkRepresents a variable in the circuit, or a reference to \xe2\x80\xa6CgSame as [crate::var::VarInfo], but with Term based Var.Ela variable or a type. For example, <code>mod::A</code>, <code>x</code>, <code>y</code>, etc.BaBuiltins are imported by default.DkLike Self::bump but errors with <code>err</code> pointing to the latest \xe2\x80\xa6CeThis module is a wrapper API around noname. It is \xe2\x80\xa6AiPropagated constant valueAdStore constant valueC`Returns whether the generic parameters are emptyCgposeidon crypto builtin function for different backendsCgDebug information related to a single row in a circuit.AbThe type of error.CkMTypeInfo holds the resolved type info to pass within a \xe2\x80\xa6AiA context for the parser.Aiadd a var with a constantAb(pub, ident, type)0BbConstants declared in this module.ChReturns the concrete type for the given expression node.Clthe functions present in the scope contains at least the \xe2\x80\xa6DcRetrieves the FnInfo for the <code>main()</code> function. This \xe2\x80\xa6Anmultiply a var with a constantBdReturns 1 if lhs != rhs, 0 otherwiseB`print the log given the log_infoB`is it surrounded by parenthesis?CmYou can use this to serialize an arkworks type with serde \xe2\x80\xa6Aj<code>let lhs = rhs</code>CjThis trait allows different backends to have different \xe2\x80\xa6Clan R1CS constraint Each constraint comprises of 3 linear \xe2\x80\xa6ChAn input is a name, and a list of field elements (in \xe2\x80\xa6Bb<code>lhs.method_name(args)</code>CfThe module preceding structs, functions, or variables.CfKeeps track of the signature of a user-defined struct.BoThe environment we use to type check functions.CfWe use the scalar field of Vesta as our circuit field.CjReturns the constant variable info for the given fully \xe2\x80\xa6ChReturns true if the given string is a number in decimal.CkUsed mainly for error reporting, when we don\xe2\x80\x99t have a \xe2\x80\xa6ClThere can be case expression node doesn\xe2\x80\x99t have a type. \xe2\x80\xa6CkMapping from node id to TyKind. This can be used by the \xe2\x80\xa6AoParse a hint function signatureBoStores type information about a local variable.CmStores type information about a local variable. Note that \xe2\x80\xa6BiRepresents a cell in the execution trace.Ad<code>lhs.rhs</code>BjA trait to display [Field] in pretty ways.BgResolved types for a function signatureCfThe environment we use to type check a noname program.Aocontains all the witness valuesCgBackends should implement this function to load and \xe2\x80\xa6CiYou can use this to deserialize an arkworks type with \xe2\x80\xa6AhPop the last loop scope.AhThe file we\xe2\x80\x99re parsingCaReturns true if a scope is a prefix of our scope.0CkReturns the struct info for the given fully qualified name.CdThis trait serves as an alias for a bundle of traitsClExprMonoInfo holds the monomorphized expression node and \xe2\x80\xa6CiA public output. This is tracked separately as public \xe2\x80\xa6CfAn error type associated with <code>R1CSWriter</code>.CkThis should be called only when you want to constrain a \xe2\x80\xa6AoGenerate the asm for a backend.lInit circuitCmSince currently we don\xe2\x80\x99t support unrolling, the generic \xe2\x80\xa6CnMonomorphize the main function. This is the entry point of \xe2\x80\xa6AmReturns a new unique node id.CbRecursively resolve a type based on generic valuesBoReturns the resolved signature of the function.BiNumber of columns in the execution trace.AbAny string literalCmStores type information about a local variable. Note that \xe2\x80\xa60Ccadd a constraint to assert a var equals another varCoLike Self::bump but errors if the token is not <code>typ</code>Cmtype checks a function call. Note that this can also be a \xe2\x80\xa6CiGenerate the r1cs file in snarkjs format. It uses the \xe2\x80\xa6BiGenerate the wtns file in snarkjs format.CnRetrieves type information on a variable, given a name. If \xe2\x80\xa6000CmReturns true if the given string is an identifier (starts \xe2\x80\xa6BdReturns whether it is in a for loop.ClThis retrieves a dependency listed in the manifest file. \xe2\x80\xa6CiThis adds a few utility functions for serializing and \xe2\x80\xa6AlPushes a new for loop scope.BkVery dumb way to write an ordered hash set.CmReturns true if the given string is an hexadecimal string \xe2\x80\xa6DkCompares two <code>TyKind</code> types to determine if they match based \xe2\x80\xa6Ckcontains the public outputs, which are also part of the \xe2\x80\xa6AeThe compiled circuit.CnA struct to export r1cs circuit and witness to the snarkjs \xe2\x80\xa6CiAn error type associated with <code>WitnessWriter</code>.Cbadd a constraint to assert a var equals a constantBbReturns the number of constraints.Ad<code>[ ... ]</code>ClThe generated witness type for the backend. Each backend \xe2\x80\xa6CmAn intermediate struct for SnarkjsExporter to reorder the \xe2\x80\xa6CnThe directory under the user home directory containing all \xe2\x80\xa6CiThe directory under [NONAME_DIRECTORY] containing the \xe2\x80\xa6AaTuple DeclarationAfProcess a public inputB`Adds the public input cell vars.CfExtract all generic parameters. Since the function \xe2\x80\xa6ClRecursively extract generic parameters from GenericArray \xe2\x80\xa6CeFinalize the circuit by doing some sanitizing checks.CkFinal checks for generating the circuit. todo: we might \xe2\x80\xa6BcGenerate the witness for a backend.CkGenerate the witnesses This process should check if the \xe2\x80\xa6BjA wrapper for the backend generate_witnessCkCreate a new cell variable and record it. It increments \xe2\x80\xa6CmCreate a new CellVar and record in witness_vector vector. \xe2\x80\xa6BkGeneric parameters for a function signatureCnAn array with symbolic size. This is an intermediate type. \xe2\x80\xa6CfOr it\xe2\x80\x99s a linear combination of internal circuit \xe2\x80\xa6CfLinear combination of variables and constants. For \xe2\x80\xa6CgThe directory under NONAME_DIRECTORY containing all \xe2\x80\xa6CkThe directory under NONAME_DIRECTORY containing all the \xe2\x80\xa6Ai<code>[item; size]</code>AgProcess a private inputBaAdds the private input cell vars.AgProcess a public outputBaAdds the public output cell vars.AiMonomorphize a statement.B`kimchi uses a transposed witnessDhAn array or tuple access, for example: <code>lhs[idx]</code> As both \xe2\x80\xa6CeA storage to manage the variables in function scopes.Cjcontains the public inputs, which are also part of the \xe2\x80\xa6CkBecause we don\xe2\x80\x99t support forloop unrolling, we should \xe2\x80\xa6BcMonomorphize a block of statements.CfReturns the monomorphized function name, using the \xe2\x80\xa6CfSame as [Self::reassign_var], but only reassigns a \xe2\x80\xa60CgReturns the dependencies of a package (given it\xe2\x80\x99s \xe2\x80\xa6CjOverall, the function call checking process is as follows:CmUpdate the type of a struct field. When the assignment is \xe2\x80\xa6Aldownload package from githubCeReturns true if the given string is generic parameterAl<code>name { fields }</code>CiReturns true if the given string is an identifier or typeCmRecursively assign values to the generic parameters based \xe2\x80\xa6CaResolve generic values for each generic parameterCkReturns true if the function signature contains generic \xe2\x80\xa6ChResolves the generic values based on observed arguments.CkThis should not be used directly. Check [get_tast] instead.DkA valid package must have a valid <code>Noname.toml</code> as well as a \xe2\x80\xa6")