<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>noname</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">noname</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://www.github.com/mimoo/noname" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="noname"><a class="header" href="#noname">NoName</a></h1>
<p>This is the book on NoName, a high-level language to write circuits using the <a href="https://github.com/o1-labs/proof-systems">kimchi</a> zero-knowledge proof system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Noname is a language that closely resembles Rust.</p>
<p>For example, in the following program you can see a <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}</code></pre></pre>
<p>The only differences with Rust are:</p>
<ul>
<li>The <code>pub</code> keyword is used to mark <em>public</em> inputs. By default all arguments are private.</li>
<li><code>assert_eq</code> is not a macro, there are no macros in noname.</li>
<li>a <code>Field</code> type is used as main types everywhere. It is defined in <code>field.rs</code> to be the pasta Fp field (the base field of the Pallas curve). If these words mean nothing to you, just see <code>Field</code> as a large number. Ideally programs should be written without this type, but for now custom types do not exist.</li>
</ul>
<p>To run such a file, and assuming you have <a href="https://rustup.rs/">Rust</a> installed, you can type in the terminal:</p>
<pre><code>$ cargo run -- --path path/to/file.no --private-inputs '{"private_input": ["1"]}' --public-inputs '{"public_input": ["1"]}'
</code></pre>
<p>As you can see, inputs are passed with a JSON format, and the values are expected to be encoded in decimal numbers.</p>
<h2 id="builtins-and-use-statements"><a class="header" href="#builtins-and-use-statements">Builtins and use statements</a></h2>
<p>Some builtin functions are available by default:</p>
<ul>
<li><code>assert_eq</code> to check that two field elements are equal</li>
<li><code>assert</code> to check that a condition is true.</li>
</ul>
<p>Like in Rust, you can also import other libraries via the <code>use</code> keyword.
If you do this, you must know that you can only import a library, but not its functions (and types, and constants) directly.</p>
<p>For example, to use the poseidon function from the crypto library (or module), you must import <code>std::crypto</code> and then qualify your use of <code>crypto::poseidon</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::crypto;

fn main(pub public_input: Field, private_input: [Field; 2]) {
    let digest = crypto::poseidon(private_input);
    assert_eq(digest[0], public_input);
}</code></pre></pre>
<p>Note that currently, only built-in libraries (written in Rust) are working.
In the future we’d like for other libraries to be written in the noname language.</p>
<h2 id="field"><a class="header" href="#field">Field</a></h2>
<p>The <code>Field</code> type is the primitive type upon which all other types are built.
It is good to know about it as it is used in many places, and is error prone: it does not match the size of commonly-found types like <code>u32</code> and <code>u64</code> and can have unexpected behaviors as it can overflow or underflow  without emitting an error.</p>
<p>Ideally, you should never use the <code>Field</code> type, but currently the library is quite limited and the ideal world is far away.</p>
<p>Note that you can define <code>Field</code> elements directly in the code by writing a decimal number directly. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let y = 4;
assert_eq(x, 2);
assert_eq(y, 4);
<span class="boring">}</span></code></pre></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>While there are no dynamic arrays (or vectors), you can use fixed-size arrays like in Rust.</p>
<p>For the moment, I believe that arrays can only be declared in a function argument as the following declaration hasn’t been implemented yet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, y];
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>Booleans are similar to Rust’s boolean. They are currently the only built-in type besides <code>Field</code> and arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true;
let y = false;
assert(!(x &amp;&amp; y));
<span class="boring">}</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>Variables are by default not mutable. To make a variable mutable, you must use the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 1;
x = 2; // GOOD

let y = 1;
y = x + y; // BAD
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For loops</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: [Field; 3]) {
    let mut sum = 0;

    for i in 0..3 {
        sum = sum + private_input[i];
    }

    assert_eq(sum, public_input);
}</code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Like variables and function names, constants must be lowercase.</p>
<p>At the moment they can only represent field elements. Perhaps it would be nice to be able to represent different types in the future.</p>
<pre><pre class="playground"><code class="language-rust">const player_one = 1;
const player_two = 2;

fn main(pub player: Field) -&gt; Field {
    assert_eq(player_one, player);
    let next_player = player + 1;
    assert_eq(player_two, next_player);
    return next_player;
}</code></pre></pre>
<h2 id="if-else-statements"><a class="header" href="#if-else-statements">If Else statements</a></h2>
<p>Currently, if/else statements are not supported. Only the ternary operator is:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub xx: Field) {
    let plus = xx + 1;
    let cond = xx == 1;
    let yy = cond ? plus : xx ;
    assert_eq(yy, 2);
}</code></pre></pre>
<p>The two branches of the ternary operator must be variables (as in the example), or array accesses (e.g. <code>thing[0]</code>), or field accesses (e.g. <code>thing.field</code>).</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><pre class="playground"><code class="language-rust">fn add(x: Field, y: Field) -&gt; Field {
    return x + y;
}

fn double(x: Field) -&gt; Field {
    return x + x;
}

fn main(pub one: Field) {
    let four = add(one, 3);
    assert_eq(four, 4);

    let eight = double(4);
    assert_eq(eight, double(four));
}</code></pre></pre>
<h2 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    x: Field,
    y: Field,
}

fn main(pub x: Field, pub y: Field) {
    let thing = Thing {
        x: 1,
        y: 2,
    };
    
    assert_eq(thing.x, x);
    assert_eq(thing.y, y);
}</code></pre></pre>
<h2 id="methods-on-custom-types"><a class="header" href="#methods-on-custom-types">Methods on custom types</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    x: Field,
    y: Field,
}

fn Thing.new(x: Field, y: Field) -&gt; Thing {
    return Thing {
        x: x,
        y: y,
    };
}

fn Thing.verify(self, v: Field) {
    assert_eq(self.x, v);
    assert_eq(self.y, v + 1);
}

fn Thing.update_and_verify(self) {
    let new_thing = Thing {
        x: self.x + 1,
        y: self.y + 1,
    };

    new_thing.verify(2);
}

fn main(pub x: Field) {
    let thing = Thing.new(x, x + x);
    thing.update_and_verify();
}</code></pre></pre>
<p>technically you can even call static methods from a variable of that type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = thing.new(3, 4);
<span class="boring">}</span></code></pre></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>The compilation of noname programs goes through the following flow:</p>
<ol>
<li><strong>Lexer</strong>. A lexer (<code>lexer.rs</code>) is used to parse the source code into a list of tokens. This is pretty primitive, but will detect some minor syntax issues.</li>
<li><strong>Parser</strong>. A parser (<code>parser.rs</code>) is used to parse meaning from the code. It will convert the tokens output by the lexer into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a> using strong types like <a href=""><code>Statement</code></a> and <a href=""><code>Expression</code></a> (TODO: link to rust doc). It will also error if some code does not make sense according to the grammar (see the <a href="grammar.html">Grammar chapter</a>).</li>
<li><strong>Type checking</strong>. A type checker (<code>type_checker.rs</code>) takes the AST produced by the parser and does import resolution and type checking:
<ul>
<li><strong>Built-in functions</strong>. Functions like <code>assert_eq</code> are injected into the environment.</li>
<li><strong>Custom imports</strong>. Modules imported via the <code>use</code> keyword are resolved and added to the environment. For now, these can only be built-in functions, and noname functions or libraries are not supported (of course it is essential to support them in the future).</li>
<li><strong>Type checking</strong>. The type checker verifies that the types of each variables and expressions in the AST make sense. It is a very simple type checker that can do some simple type inference. Temporary type information (type of an expression) is not stored, and is thrown away as soon as the type checker can afford it. a TAST for typed AST is returned, but it mostly contains resolved imports and most type information has been thrown away.</li>
</ul>
</li>
<li><strong>Gate construction</strong>. The TAST produced by the type checker is passed to the circuit writer (<code>circuit_writer.rs</code>), also called the constraint writer, which goes through it one more time and converts it into:
<ul>
<li><strong>compiled circuit</strong>: a series of gates and wires</li>
<li><strong>prover instructions</strong>: instructions on how to run the function for the witness generation (used by the prover)</li>
</ul>
</li>
</ol>
<p>A simple ASM language is also used, and the circuit can be encoded in this language. See the <a href="asm.html">ASM chapter</a>.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>A note on topology:</p>
<ul>
<li><strong>functions</strong>: noname functions each contain their scope and can be interacted with their interface (arguments and return value)</li>
<li><strong>module/program</strong>: a noname module is a single file (this is a nice current limitation of noname) containing functions, constants, and structures.</li>
<li><strong>library</strong>: a noname library is a module/program without a <code>main()</code> function, as well as dependencies (other libraries)</li>
<li><strong>executable</strong>: a noname executable is like a library, except that its module/program has a <code>main()</code> function.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar"><a class="header" href="#grammar">Grammar</a></h1>
<p>The syntax of the noname language is described through its grammar.</p>
<p>We use a notation similar to the Backus-Naur Form (BNF)
to describe the grammar:</p>
<pre>
land := city "|"
 ^        ^   ^
 |        |  terminal: a token
 |        |
 |      another non-terminal
 |
 non-terminal: definition of a piece of code
city := [ sign ] "," { house }
        ^            ^
        optional     |
                    0r or more houses
sign := /a-zA-Z_/
        ^
        regex-style definition
</pre>
<p>There are some comments in the parser code (<code>parser.rs</code>) that attempt to define this grammar.</p>
<p>Essentially, it is made to look like Rust, but with some differences of philosophies:</p>
<ul>
<li>expressions cannot be statements, unless they return no value (act using side effects).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spans"><a class="header" href="#spans">Spans</a></h1>
<p>To be able to efficiently track errors, we have a span type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Span(pub usize, pub usize);
<span class="boring">}</span></code></pre></pre>
<p>which represents a location in the original source code:</p>
<ul>
<li>the first number is the offset in the source code file</li>
<li>the second number is the length of the span (e.g. 1 character)</li>
</ul>
<p>We start tracking spans in the lexer, and then pass them around to the parser, and then to the compiler. Even gates and wirings have spans associated with them so that we can easily debug those.</p>
<h2 id="filename"><a class="header" href="#filename">Filename</a></h2>
<p>The filename is currently missing from the <code>Span</code>, it is annoying to add it as a <code>String</code> because then we can’t easily copy the span around (<code>String</code> is not <code>Copy</code> but <code>Clone</code>).</p>
<p>One way to solve this, is to add the filenames in a <code>Hashmap&lt;usize, String&gt;</code>, and have the <code>usize</code> be in the <code>Span</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths"><a class="header" href="#paths">Paths</a></h1>
<p>Paths are structures identifying snippets of code that look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>some_module::some_ident.stuff.z
<span class="boring">}</span></code></pre></pre>
<p>The identifier <code>some_module</code>, appearing before the <code>::</code>, is an optional module, pointing to code that exists in another library. It is always lowercase.</p>
<p>The identifier <code>some_ident</code> is mandatory. It can represent a type (if it starts with a capital letter), a function name, a variable name, a constant name, etc.</p>
<p>More identifiers can be concatenated together to form a longer path (using <code>.</code>).
A path is represented like this internally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A path represents a path to a type, a function, a method, or a constant.
/// It follows the syntax: `module::X` where `X` can be a type, a function, a method, or a constant.
/// In the case it is a method `a` on some type `A` then it would read:
/// `module::A.a`.
#[derive(Debug, Clone)]
pub struct Path {
    /// A module, if this is a foreign import.
    pub module: Option&lt;Ident&gt;,

    /// The name of the type, function, method, or constant.
    /// It's a vector because it can also be a struct access.
    pub name: Vec&lt;Ident&gt;,

    /// Its span.
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expressions-using-path"><a class="header" href="#expressions-using-path">Expressions using Path</a></h2>
<p>A path does not represent an expression by itself. The following expressions make use of <code>path</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExprKind {
    /// `module::some_fn()`
    FnCall {
        name: Path,
        args: Vec&lt;Expr&gt;,
    },

    /// `module::SomeType.some_method()`
    MethodCall {
        self_name: Path,
        method_name: Ident,
        args: Vec&lt;Expr&gt;,
    },

    /// `module::some_var` or
    /// `module::SomeType.some_field.some_other_field`
    Variable(Path),

    /// `module::SomeType.some_field[some_expr]` or
    /// `module::some_const[some_expr]`
    ArrayAccess {
        name: Path,
        idx: Box&lt;Expr&gt;,
    },

    /// `module::SomeType { field1: expr1; field2: expr2 }`
    CustomTypeDeclaration(Path, Vec&lt;(Ident, Expr)&gt;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-checker"><a class="header" href="#type-checker">Type Checker</a></h1>
<p>Noname uses a simple type checker to ensure that all types are consistent in the program.</p>
<p>For example, in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}</span></code></pre></pre>
<p>the type checker will ensure that <code>y</code> and <code>z</code> are both field elements (because the operation <code>+</code> is used).</p>
<p>And in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq(a, b);
<span class="boring">}</span></code></pre></pre>
<p>the type checker will ensure that <code>a</code> and <code>b</code> are of the same types, since they are being compared.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>The type checker can do some simple type inference. For example, in the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}</span></code></pre></pre>
<p>the type of <code>x</code> is inferred to be the same as the type of <code>y</code> and <code>z</code>.</p>
<p>Inference is willingly kept naive, as more type inference would lead to less readable code.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The type checker must be aware of scopes, as it keeps track of the type of variables and functions that are local to each scope.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
for i in 0..2 {
    let y = x + 1; // x exists inside of this for loop
}
let z = 1 + y; // BAD: y doesn't exist outside of the for loop
<span class="boring">}</span></code></pre></pre>
<p>To do this, each function is passed an <a href="">Environment</a> which contains a list of all variables along with their type information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Environment {
    /// created by the type checker, gives a type to every external variable
    pub var_types: HashMap&lt;String, TypeInfo&gt;,

    // ...

    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>So that shadowing is disallowed, even in different scopes, there is only one variable that is stored, but the scope is stored in <code>TypeInfo</code> and matched against the current scope to see if the current scope is the same or a direct child.</p>
<p>An environment is unique to a function, as it is important that different functions can use the same variable names.</p>
<p>Some notes:</p>
<ul>
<li>Currently the notion of module is quite shaky. It is used mostly for <code>crypto::poseidon</code> at the moment.</li>
<li><code>functions</code> is mostly used for builtins like <code>assert_eq</code></li>
<li><code>modules</code> is mostly used for the functions in <code>std::crypto</code>, which only contains <code>crypto::poseidon</code> atm.</li>
</ul>
<p>more:</p>
<ul>
<li>I think Environment mixes things</li>
<li>we should be able to create a new Environment whenever we parse a new function, so the functions/modules should be part of another (AvailableToAllScopes)</li>
<li>variables is something that has nothing to do with the “Type” Environment and should be moved elsewhere no? GateCreationEnv?</li>
<li>there needs to be a namespace in the typeinfo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noname-asm"><a class="header" href="#noname-asm">noname ASM</a></h1>
<p>The circuit that noname compiles to can be serialized as a simple ASM language. For example the following noname program:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}</code></pre></pre>
<p>will be compiled to the following noname asm:</p>
<pre><code>@ noname.0.5.0

DoubleGeneric&lt;1&gt;
DoubleGeneric&lt;1,1,-1&gt;
DoubleGeneric&lt;1,0,0,0,-2&gt;
DoubleGeneric&lt;1,-1&gt;
(0,0) -&gt; (1,1)
(1,2) -&gt; (3,1)
(2,0) -&gt; (3,0)
</code></pre>
<p>which includes:</p>
<ul>
<li><strong>the version</strong> of noname used to compile this circuit. This is important as the prover needs to know what version of noname to use to prove executions of this circuit.</li>
<li><strong>a list of gates</strong> and how they are tweaked (the values in the brackets).</li>
<li><strong>a list of wires</strong> which is canonically ordered so that every compilation gives the same resulting noname asm.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>User can define custom structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: Field,
    y: Field,
}
<span class="boring">}</span></code></pre></pre>
<p>and can declare and access such structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
let z = thing.x + thing.y;
<span class="boring">}</span></code></pre></pre>
<p>Internally, a struct is represented within the <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<h2 id="a-method-on-what"><a class="header" href="#a-method-on-what">A method on what?</a></h2>
<p>There’s one problem when handling methods in the circuit-writer: how do you know where the code of that method is? For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
let z = thing.valid(3);
<span class="boring">}</span></code></pre></pre>
<p>at this point the circuit-writer knows that <code>Thing</code> has a method called <code>valid</code>, but will still wonder what the type of <code>thing</code> is.</p>
<p>due to this, the circuit-writer needs to store the type of local variables in scope. And this is why <code>FnEnv</code> also keeps track of the type of local variables:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Is used to store functions' scoped variables.
/// This includes inputs and output of the function,  as well as local variables.
/// You can think of it as a function call stack.
pub struct FnEnv {
    /// The current nesting level.
    /// Starting at 0 (top level), and increasing as we go into a block.
    current_scope: usize,

    /// Used by the private and public inputs,
    /// and any other external variables created in the circuit
    /// This needs to be garbage collected when we exit a scope.
    /// Note: The `usize` is the scope in which the variable was created.
    vars: HashMap&lt;String, (usize, VarInfo)&gt;,
}

/// Information about a variable.
#[derive(Debug, Clone)]
pub struct VarInfo {
    /// The variable.
    pub var: Var,

    /// We keep track of the type of variables, even though we're not in the typechecker anymore,
    /// because we need to know the type for method calls.
    pub typ: TyKind,
}
<span class="boring">}</span></code></pre></pre>
<p>This still doesn’t fix our problem. In the line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
<span class="boring">}</span></code></pre></pre>
<p>the local variable <code>thing</code> is stored, but the right-hand side is computed via the <code>compute_expr()</code> function which will go through the AST and potentially create different anonymous variables until it can compute a value.</p>
<p>There’s three ways to solve this:</p>
<ol>
<li>Either the type checker stores type information about each expression it parses. This is what the Rust compiler does I believe: each <code>Expr</code> AST node has a unique node identifier that can be used to search type information in a map.</li>
<li>Or, more simply, the circuit-writer’s <code>compute_expr()</code> function that returns an <code>Option&lt;Var&gt;</code> could be modified to return <code>Option&lt;VarInfo&gt;</code>. This is a bit annoying as we’re recomputing things we’ve done in the type checker.</li>
<li>A variant of the previous option is to change <code>Var</code> so that it also contains a type (might as well).</li>
</ol>
<p>So we implement option 1: the type checker now stores the type information of each <code>Expr</code> node in the AST under a hashmap that is later passed to the circuit-writer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The environment we use to type check a noname program.
pub struct TypedGlobalEnv {
    // ...

    /// Mapping from node id to TyKind.
    /// This can be used by the circuit-writer when it needs type information.
    node_types: HashMap&lt;usize, TyKind&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals-and-the-const-keyword"><a class="header" href="#literals-and-the-const-keyword">Literals and the <code>const</code> keyword</a></h1>
<p>We want to be able to support a few things:</p>
<ul>
<li>writing numbers that will act as field elements directly in the code</li>
<li>writing numbers that will act as relatively small numbers (for indexing into arrays for example) in the code</li>
<li>writing functions that will accept constant arguments. For example to index into an array.</li>
</ul>
<p>The first two points allow us to write things like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3;
assert_eq(y[5], 4);
<span class="boring">}</span></code></pre></pre>
<p>The third point allows us to write things like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn House.get(self, room: Field) -&gt; Field {
    return House.rooms[room];
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>House</code> takes a <code>Field</code> here, it can in theory be used with anything during type checking.</p>
<p>This is bad. There are two solutions:</p>
<ol>
<li>During type checking, when we realize that <code>room</code> is used to index into an array, we enforce that it must be a constant value during compilation.</li>
<li>We create a distinct type for constants and literals.</li>
</ol>
<p>Approach 1. is not elegant, because it means that it is not clear from the signature of the function alone that the <code>room</code> argument must be a constant.
The user of the function will only get warned when trying to compile the program.</p>
<p>Approach 2. is interesting, because we already have such a type internally to track literals: a <code>BigInt</code>.
The name is a bit misleading in the case of array accesses, because we additionally enforce that it is NOT a big integer, but rather a 32-bit integer (<code>u32</code> in Rust).</p>
<h2 id="implementing-a-literal-type"><a class="header" href="#implementing-a-literal-type">Implementing a literal type</a></h2>
<p>Approach 2 can be implemented in two ways:</p>
<p>a. Use a brand new type, like <code>BigInt</code> for literals.
b. Use a <code>const</code> attribute to indicate that it is a constant.</p>
<p>Approach a. is a bit clumsy in my opinion because the developer needs to remember about a new type name, and understand the distinction with that and <code>Field</code>.</p>
<p>On the other hand, approach b. uses the <code>const</code> keyword which is already well-known in many compiled programming languages.</p>
<p>What about this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn House.get(self, const room: Field) -&gt; Field {
// versus
fn House.get(self, room: const Field) -&gt; Field {
<span class="boring">}</span></code></pre></pre>
<p>To contrast, the two other existing attributes (<code>pub</code> and <code>mut</code>) are placed in front of the variable names, not the type names.</p>
<p>One could argue that the type is the same, but the variable being passed is a constant, and so it makes more sense to implement the first version.
This is what we do in noname.</p>
<p>At the time of this writing, the <code>const</code> keyword only seems to make sense in a function argument, and so is implemented in the same way as the <code>pub</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AttributeKind {
    Pub,
    Const,
}

pub struct Attribute {
    pub kind: AttributeKind,
    pub span: Span,
}

pub struct FnArg {
    pub name: Ident,
    pub typ: Ty,
    pub attribute: Option&lt;Attribute&gt;,
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>When a function is parsed by the type checker, a <code>const Field</code> is transformed into a <code>BigInt</code>.
And as such, the type checker will be happy with that variable being used to index into an array, or being used by other functions expecting a constant.</p>
<p>What about other types being <code>const</code>?
I don’t think it makes sense for now, as I can only think of array access requiring this.
So we don’t implement it.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="literals.html#admonition-note"></a>
</div>
<div>
<p>If we do want to support that one day, we will have to track more than <code>TyKind</code> in the typechecker…
This can be achieved by adding a <code>const</code> field in the <code>TypeInfo</code> structure that tracks type-related data on noname variables present in the scope.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<h2 id="field-accesses"><a class="header" href="#field-accesses">Field accesses</a></h2>
<p>A field access is an access to a field of a structure, by writing <code>struct.field</code>.
It is represented as an expression in noname:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExprKind {
    // ...
    FieldAccess { lhs: Box&lt;Expr&gt;, rhs: Ident }
<span class="boring">}</span></code></pre></pre>
<p>The reason why the left-hand side is also an expression, as opposed to just a variable pointing to a struct, is that we need to support code like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = b.c.d;
let e = f[3].g;
<span class="boring">}</span></code></pre></pre>
<p>Note that there are other use cases that are not allowed at the moment for readability reasons.
For example we could have allowed the following to be valid noname:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res = some_function().some_field;
<span class="boring">}</span></code></pre></pre>
<p>but instead we require developers to write their logic in the following way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let temp = some_function();
let res = temp.some_field;
<span class="boring">}</span></code></pre></pre>
<p>In the example</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = b.c.d;
<span class="boring">}</span></code></pre></pre>
<p>the expression node representing the right-hand side could be seen as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExprKind::FieldAccess {
    lhs: Expr { kind: ExprKind::FieldAccess { // x.y
        lhs: Expr { kind: ExprKind::Variable { name: "x" } },
        rhs: Ident { value: "y" },
    },
    rhs: Ident { value: "z" }, ///  [x.y].z
}
<span class="boring">}</span></code></pre></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Imagine that we want to mutate a variable.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.y.z = 42;
x[4] = 25;
<span class="boring">}</span></code></pre></pre>
<p>At some point the <a href="">circuit-writer</a> would have to go through an expression node looking like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExprKind::Assignment {
    lhs: /* the left-hand side as an Expr */,
    rhs: Expr { kind: ExprKind::BigInt { value: 42 } },
}
<span class="boring">}</span></code></pre></pre>
<p>At this point, the problem is that to go through each expression node, we use the following API, which only gets us a <code>Var</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_expr(
    &amp;mut self,
    global_env: &amp;GlobalEnv,
    fn_env: &amp;mut FnEnv,
    expr: &amp;Expr,
) -&gt; Result&lt;Option&lt;Var&gt;&gt; {
<span class="boring">}</span></code></pre></pre>
<p>So parsing the <code>x.y</code> node would return a variable that either represents <code>x</code> or represents <code>y</code>.
The parent call would then use the result to produce <code>x.y.z</code> with a similar outcome.
Then, we would either have <code>x</code> or <code>z</code> (depending on the strategy we chose) when we reach the assignment expression node.
Not leaving us enough information to modify the variables of <code>x</code> in our <a href="">local function environment</a>.</p>
<p>What we really need when we reach the assignment node is the following:</p>
<ul>
<li>the name of the variable being modified (in both cases <code>x</code>)</li>
<li>if the variable is mutable or not (it was defined with the <code>mut</code> keyword)</li>
<li>the range of circuit variables in the <code>Var.cvars</code> of <code>x</code>, that the <code>x.y.z</code> field access, or the <code>x[42]</code> array access, represents.</li>
</ul>
<h2 id="varorref-overview"><a class="header" href="#varorref-overview"><code>VarOrRef</code> Overview</a></h2>
<p>The VarOrRef enum is used to represent either a variable or a reference to a variable within expressions.
Here is a concise overview:</p>
<pre><code>pub enum VarOrRef&lt;B: Backend&gt; {
    /// A variable.
    Var(Var&lt;B::Field, B::Var&gt;),

    /// A reference to a variable, potentially narrowing down to a range within it.
    Ref {
        var_name: String,
        start: usize,
        len: usize,
    },
}
</code></pre>
<p><code>Var</code>: Represents a complete variable in the environment.</p>
<p><code>Ref</code>: Represents a reference to a variable, including:</p>
<ul>
<li><code>var_name</code>: The name of the variable.</li>
<li><code>start</code>: The starting index of the slice or field.</li>
<li><code>len</code>: The length of the slice or field.</li>
</ul>
<p>Every expression node in the AST is resolved as a <code>VarOrRef</code>, an enum that represents either a variable, or a reference to a variable.  The sole reason to use a reference is when the variable is <strong>mutable</strong>, in which case you must be able to go to the list of variables present in the scope and mutate the correct one (so that if some logic tries to mutate it, it can). That’s why, a <code>var_name</code> is stored in a reference. We also pass a <code>(start, len)</code> tuple to handle <strong>mutable slices</strong>. As we need to remember exactly where we are in the original array. As a slice is a narrowing of an array, we must not lose track of which array we were looking at originally (as this is what needs to be mutated). This ensures accurate modification of the variable’s state, maintaining the integrity of the mutable references.</p>
<h3 id="circuit-writer"><a class="header" href="#circuit-writer">Circuit writer</a></h3>
<p>To implement this in the circuit writer, we follow a common practice of tracking <strong>references</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Represents a variable in the circuit, or a reference to one.
/// Note that mutable variables are always passed as references,
/// as one needs to have access to the variable name to be able to reassign it in the environment.
pub enum VarOrRef {
    /// A [Var].
    Var(Var),

    /// A reference to a noname variable in the environment.
    /// Potentially narrowing it down to a range of cells in that variable.
    /// For example, `x[2]` would be represented with "x" and the range `(2, 1)`,
    /// if `x` is an array of `Field` elements.
    Ref {
        var_name: String,
        start: usize,
        len: usize,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>and we modify the <a href="">circuit-writer</a> to always return a <a href=""><code>VarOrRef</code></a> when processing an expression node in the AST.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="expressions.html#admonition-note"></a>
</div>
<div>
<p>While the type checker already checks if the <code>lhs</code> variable is mutable when it encounters an assignment expression,
the circuit-writer should do its best to pass references only when a variable is known to be mutable.
This way, if there is a bug in the type checker, this will turn unsafe code into a runtime error.</p>
</div>
</div>
<p>An array access, or a field access in a struct, is processed as a narrowing of the range we’re referencing in the original variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl VarOrRef {
    fn narrow(&amp;self, start: usize, len: usize) -&gt; Self {
        match self {
            VarOrRef::Var(var) =&gt; {
                let cvars = var.range(start, len).to_vec();
                VarOrRef::Var(Var::new(cvars, var.span))
            }

            //      old_start
            //      |
            //      v
            // |----[-----------]-----| &lt;-- var.cvars
            //       &lt;---------&gt;
            //         old_len
            //
            //
            //          start
            //          |
            //          v
            //      |---[-----]-|
            //           &lt;---&gt;
            //            len
            //
            VarOrRef::Ref {
                var_name,
                start: old_start,
                len: old_len,
            } =&gt; {
                // ensure that the new range is contained in the older range
                assert!(start &lt; *old_len); // lower bound
                assert!(start + len &lt; *old_len); // upper bound
                assert!(len &gt; 0); // empty range not allowed

                Self::Ref {
                    var_name: var_name.clone(),
                    start: old_start + start,
                    len,
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="type-checker-1"><a class="header" href="#type-checker-1">Type checker</a></h3>
<p>While the type checker does not care about the range within a variable, it also needs to figure out if a variable is mutable or not.</p>
<p>That information is in two places:</p>
<ol>
<li>it is stored under the variable’s name in the local environment</li>
<li>it is also known when we look up a variable, and we can thus bubble it up to the parent expression nodes</li>
</ol>
<p>Implementing solution 1. means bubbling up the variable name, in addition to the type, associated to an expression node.</p>
<p>Implementing solution 2. means bubbling up the mutability instead.</p>
<p>As it is possible that we might want to retrieve additional information in the future, we chose to implement solution 1. and carry the variable name in addition to type information when parsing the AST in the type checker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>In noname, the concept of a module is basically a file. A project either is a binary (<code>main.no</code>) or a library (<code>lib.no</code>). That’s it.</p>
<p>A binary or a library can use other libraries by importing them. To do that, a binary or library’s manifest file <code>Noname.toml</code> must contain a <code>dependencies</code> key listing all the other libraries as Github handles like <code>user/repo</code> (e.g. <code>mimoo/sudoku</code>).
Libraries will then be retrieved from Github.</p>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="modules.html#admonition-note"></a>
</div>
<div>
<p>Currently there is no versioning. Not because it’s not important, but because I haven’t had the time to implement it.</p>
</div>
</div>
<p>Each library can be imported in code with the following command:</p>
<pre><code>use module::lib;
</code></pre>
<p>For example, currently you automatically have access to the <code>std</code> module:</p>
<pre><code>use std::crypto;

fn main(pub digest: [Field; 2]) {
    let expected_digest = crypto::poseidon([1, 2]);
    assert_eq(expected_digest, digest);
}
</code></pre>
<p>Each library is seen as a module, and different modules might have the same name:</p>
<pre><code>use a::some_lib;
use b::some_lib;
</code></pre>
<p>There is currently no solution to this problem.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="modules.html#admonition-note-1"></a>
</div>
<div>
<p>This is a problem that does not exist in Rust, as there’s a single namespace that everyone shares, but that exists in Golang.
The current proposed solution is to introduce an <code>as</code> keyword, like in Rust, to be able to alias imports (e.g. <code>use a::some_lib as a_some_lib;</code>).</p>
</div>
</div>
<h2 id="dependency-graph-and-type-checking"><a class="header" href="#dependency-graph-and-type-checking">Dependency graph and type checking</a></h2>
<p>During building, a dependency graph of all dependencies is formed (and dependencies are retrieved from Github at the same time). This must be done to detect <a href="https://en.wikipedia.org/wiki/Circular_dependency">dependency cyles</a>.</p>
<p>Once this is done, a list of dependencies from leaves to roots is computed, and each dependency is analyzed in this order.
Dependencies are not compiled! As the circuit-writer is not ran. Things stop at the type checker.
For every new dependency analyzed, all TAST (typed AST) previously computed on previous dependencies are passed as argument.
This way, if a dependency A uses a dependency B, it has access to the TAST of B to perform type checking correctly.</p>
<p>As such, it is important that <code>a::some_lib</code> and <code>b::some_lib</code> are seen as two independent modules.
For this reason, we store imported modules as their fully qualified path, in the set of TASTs that we pass to the type checker.
But in the current module, we store them as their alias, so that we can use them in the code.</p>
<pre><code>TASTs: HashMap&lt;a::some_lib, TAST&gt;
TAST: contains &lt;some_lib -&gt; a::some_lib&gt;
</code></pre>
<h2 id="compilation-and-circuit-generation"><a class="header" href="#compilation-and-circuit-generation">Compilation and circuit generation</a></h2>
<p>Once type checking is done, the circuit writer is given access to all of the dependencies’ TAST (which also contain their AST).
This way, it can jump from AST to AST to generate an unrolled circuit.</p>
<h2 id="another-solution"><a class="header" href="#another-solution">Another solution</a></h2>
<p>This is a bit annoying. We need a context switcher in both the constraint writer and the type checker, and it’s almost the same code.</p>
<h3 id="type-checker-2"><a class="header" href="#type-checker-2">Type Checker</a></h3>
<h3 id="constraint-writer"><a class="header" href="#constraint-writer">Constraint Writer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CircuitWriter {
    /// The type checker state for the main module.
    // Important: this field must not be used directly.
    // This is because, depending on the value of [current_module],
    // the type checker state might be this one, or one of the ones in [dependencies].
    typed: TypeChecker,

    /// The type checker state and source for the dependencies.
    // TODO: perhaps merge {source, typed} in this type?
    dependencies: Dependencies,

    /// The current module. If not set, the main module.
    // Note: this can be an alias that came from a 3rd party library.
    // For example, a 3rd party library might have written `use a::b as c;`.
    // For this reason we must store this as a fully-qualified module.
    pub(crate) current_module: Option&lt;UserRepo&gt;,
<span class="boring">}</span></code></pre></pre>
<p>and then access to the TAST is gated so we can switch context on demand, or figure out what’s the current context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CircuitWriter {
    /// Retrieves the type checker associated to the current module being parsed.
    /// It is possible, when we jump to third-party libraries' code,
    /// that we need access to their type checker state instead of the main module one.
    pub fn current_type_checker(&amp;self) -&gt; &amp;TypeChecker {
        if let Some(current_module) = &amp;self.current_module {
            self.dependencies
                .get_type_checker(current_module)
                .expect(&amp;format!(
                    "bug in the compiler: couldn't find current module: {:?}",
                    current_module
                ))
        } else {
            &amp;self.typed
        }
    }

    pub fn expr_type(&amp;self, expr: &amp;Expr) -&gt; Option&lt;&amp;TyKind&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.node_types.get(&amp;expr.node_id)
    }

    pub fn node_type(&amp;self, node_id: usize) -&gt; Option&lt;&amp;TyKind&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.node_types.get(&amp;node_id)
    }

    pub fn struct_info(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;StructInfo&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.struct_info(name)
    }

    pub fn fn_info(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;FnInfo&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.functions.get(name)
    }

    pub fn size_of(&amp;self, typ: &amp;TyKind) -&gt; Result&lt;usize&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.size_of(&amp;self.dependencies, typ)
    }

    pub fn resolve_module(&amp;self, module: &amp;Ident) -&gt; Result&lt;&amp;UsePath&gt; {
        let curr_type_checker = self.current_type_checker();

        let res = curr_type_checker.modules.get(&amp;module.value).ok_or_else(|| {
            self.error(
                ErrorKind::UndefinedModule(module.value.clone()),
                module.span,
            )
        });

        res
    }

    pub fn do_in_submodule&lt;T, F&gt;(&amp;mut self, module: &amp;Option&lt;Ident&gt;, mut closure: F) -&gt; Result&lt;T&gt;
    where
        F: FnMut(&amp;mut CircuitWriter) -&gt; Result&lt;T&gt;,
    {
        if let Some(module) = module {
            let prev_current_module = self.current_module.clone();
            let submodule = self.resolve_module(module)?;
            self.current_module = Some(submodule.into());
            let res = closure(self);
            self.current_module = prev_current_module;
            res
        } else {
            closure(self)
        }
    }

    pub fn get_fn(&amp;self, module: &amp;Option&lt;Ident&gt;, fn_name: &amp;Ident) -&gt; Result&lt;FnInfo&gt; {
        if let Some(module) = module {
            // we may be parsing a function from a 3rd-party library
            // which might also come from another 3rd-party library
            let module = self.resolve_module(module)?;
            self.dependencies.get_fn(module, fn_name) // TODO: add source
        } else {
            let curr_type_checker = self.current_type_checker();
            let fn_info = curr_type_checker
                .functions
                .get(&amp;fn_name.value)
                .cloned()
                .ok_or_else(|| {
                    self.error(
                        ErrorKind::UndefinedFunction(fn_name.value.clone()),
                        fn_name.span,
                    )
                })?;
            Ok(fn_info)
        }
    }

    pub fn get_struct(&amp;self, module: &amp;Option&lt;Ident&gt;, struct_name: &amp;Ident) -&gt; Result&lt;StructInfo&gt; {
        if let Some(module) = module {
            // we may be parsing a struct from a 3rd-party library
            // which might also come from another 3rd-party library
            let module = self.resolve_module(module)?;
            self.dependencies.get_struct(module, struct_name) // TODO: add source
        } else {
            let curr_type_checker = self.current_type_checker();
            let struct_info = curr_type_checker
                .struct_info(&amp;struct_name.value)
                .ok_or(self.error(
                    ErrorKind::UndefinedStruct(struct_name.value.clone()),
                    struct_name.span,
                ))?
                .clone();
            Ok(struct_info)
        }
    }

    pub fn get_source(&amp;self, module: &amp;Option&lt;UserRepo&gt;) -&gt; &amp;str {
        if let Some(module) = module {
            &amp;self
                .dependencies
                .get_type_checker(module)
                .expect(&amp;format!(
                    "type checker bug: can't find current module's (`{module:?}`) file"
                ))
                .src
        } else {
            &amp;self.typed.src
        }
    }

    pub fn get_file(&amp;self, module: &amp;Option&lt;UserRepo&gt;) -&gt; &amp;str {
        if let Some(module) = module {
            &amp;self.dependencies.get_file(module).expect(&amp;format!(
                "type checker bug: can't find current module's (`{module:?}`) file"
            ))
        } else {
            &amp;self.typed.filename
        }
    }

    pub fn get_current_source(&amp;self) -&gt; &amp;str {
        self.get_source(&amp;self.current_module)
    }

    pub fn get_current_file(&amp;self) -&gt; &amp;str {
        self.get_file(&amp;self.current_module)
    }

    pub fn add_local_var(&amp;self, fn_env: &amp;mut FnEnv, var_name: String, var_info: VarInfo) {
        // check for consts first
        let type_checker = self.current_type_checker();
        if let Some(_cst_info) = type_checker.constants.get(&amp;var_name) {
            panic!(
                "type checker bug: we already have a constant with the same name (`{var_name}`)!"
            );
        }

        //
        fn_env.add_local_var(var_name, var_info)
    }

    pub fn get_local_var(&amp;self, fn_env: &amp;FnEnv, var_name: &amp;str) -&gt; VarInfo {
        // check for consts first
        let type_checker = self.current_type_checker();
        if let Some(cst_info) = type_checker.constants.get(var_name) {
            let var = Var::new_constant(cst_info.value, cst_info.typ.span);
            return VarInfo::new(var, false, Some(TyKind::Field));
        }

        // then check for local variables
        fn_env.get_local_var(var_name)
    }
<span class="boring">}</span></code></pre></pre>
<p>we basically have to implement the same in the type checker… It always sort of looks the same. A handy function is either called with <code>get_fn</code> or <code>expr_type</code> or <code>node_type</code> etc. or we call a block of code with <code>do_in_submodule</code>.</p>
<p>all of these basically start by figuring out the <code>curr_type_checker</code>:</p>
<ul>
<li>what’s the current module (<code>self.current_module</code>)?
<ul>
<li>if there is none, use the main TAST (<code>self.typed</code>)</li>
<li>otherwise find that TAST (in <code>self.dependencies</code>)</li>
<li>btw all of this logic is implemented in <code>self.current_type_checker()</code></li>
<li>the returned TAST is called <code>curr_type_checker</code></li>
</ul>
</li>
</ul>
<p>then, if we’re handling something that has a module:</p>
<ul>
<li>do name resolution (implemented in <code>resolve_module()</code>):
<ul>
<li>use <code>curr_type_checker</code> to resolve the fully-qualified module name</li>
</ul>
</li>
</ul>
<p>or if we’re executing a block within a module:</p>
<ul>
<li>save the current module (<code>self.current_module</code>)</li>
<li>replace it with the module we’re using (we have used <code>resolve_module()</code> at this point)</li>
<li>execute in the closure where <code>self</code> is passed</li>
<li>when we return, reset the current module to its previous saved state</li>
</ul>
<p>note that when we return an error, we always try to figure out which file it came from, which can be resolved via <code>self.current_module</code>.</p>
<h2 id="name-resolution-approach"><a class="header" href="#name-resolution-approach">Name resolution approach</a></h2>
<p>If we have a name resolution phase, we could do this:</p>
<ul>
<li>fully qualify all things that need to be fully qualified: structs, functions, methods (which are defined as function currently, should we not do that?), consts. And that’s it?</li>
<li>create a <code>Hashmap&lt;usize, String&gt;</code> to store all the filenames</li>
<li>add the <code>usize</code> in all <code>Span</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cellvar"><a class="header" href="#cellvar">CellVar</a></h1>
<p>A <a href="https://mimoo.github.io/noname/rustdoc/var/struct.CellVar.html"><code>CellVar</code></a> type is a type that represents an internal variable. Importantly, it is named after the fact that it relates to a specific cell, or even multiple cells if they will have the same value (using some wiring), in the execution trace.</p>
<p>A <code>CellVar</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CellVar {
    index: usize,
    span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>It is tracked using a <code>usize</code>, which is just a counter that the compiler increments every time a new <code>CellVar</code> is created.</p>
<p>A <code>CellVar</code> is created via the <code>new_internal_var</code> function which does two things: increments the variable counter, and stores some information on how to compute it (which will be useful during witness generation)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new_internal_var(&amp;mut self, val: Value, span: Span) -&gt; CellVar {
    // create new var
    let var = CellVar::new(self.next_variable, span);
    self.next_variable += 1;

    // store it in the compiler
    self.vars_to_value.insert(var, val);

    var
}
<span class="boring">}</span></code></pre></pre>
<p>a <code>Value</code> tells us how to compute the <code>CellVar</code> during witness generation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Value {
    /// Either it's a hint and can be computed from the outside.
    Hint(Box&lt;dyn Fn(&amp;Compiler, &amp;mut WitnessEnv) -&gt; Result&lt;Field&gt;&gt;),

    /// Or it's a constant (for example, I wrote `2` in the code).
    Constant(Field),

    /// Or it's a linear combination of internal circuit variables (+ a constant).
    LinearCombination(Vec&lt;(Field, CellVar)&gt;, Field),

    /// A public or private input to the function
    /// There's an index associated to a variable name, as the variable could be composed of several field elements.
    External(String, usize),

    /// A public output.
    /// This is tracked separately as public inputs as it needs to be computed later.
    PublicOutput(Option&lt;CellVar&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>Note: a <code>CellVar</code> is potentially not directly added to the rows of the execution trace.
For example, a private input is converted directly to a (number of) <code>CellVar</code>(s),
but only added to the rows when it appears in a constraint for the first time.</p>
<p>As the final step of the compilation, we double-check that all <code>CellVar</code>s have appeared in the rows of the execution trace at some point. If they haven’t, it can mean two things:</p>
<ul>
<li>A private or public input was never used in the circuit. In this case we return an error to the user.</li>
<li>There is a bug in the compiler. In this case we panic.</li>
</ul>
<p>TODO: explain the LinearCombination. I think we only need an <code>Add((Field, Var), (Field, Var), Field)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars"><a class="header" href="#vars">Vars</a></h1>
<p>We already have <a href="./cellvar.html"><code>CellVar</code></a>s, why have <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a>s?
The distinction is a matter of abstraction:</p>
<ul>
<li><code>CellVar</code>s are low-level: they track actual cells of the execution trace. When a single <code>CellVar</code> is assigned to multiple cells the wiring must make sure the cells are wired (so that they can only have the same value).</li>
<li><code>Var</code>s are a higher-level concept: they track variables that are created in the noname language either directly (e.g. <code>let x = 3</code>) or indirectly (e.g. in <code>x + (y + z)</code> the term <code>y + z</code> is stored under an anonymous <code>Var</code>)</li>
</ul>
<p>While a <code>CellVar</code> represents a single field element, a <code>Var</code> can potentially represent several field elements (and as such several cells in the execution trace).
Here are some examples of <code>Var</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a constant
let x = 5;

// a field element that will be computed at runtime
let y = private_input + 1;

// a builtin type, like an array, or a bool
let z = [y, x, 6];

// or a custom type
let s = Thing { x, y };
<span class="boring">}</span></code></pre></pre>
<p>Internally, a <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> is represented as such:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A constant value created in a noname program
pub struct Constant {
    /// The actual value.
    pub value: Field,

    /// The span that created the constant.
    pub span: Span,
}

/// Represents a cell in the execution trace.
pub enum ConstOrCell {
    /// A constant value.
    Const(Constant),

    /// A cell in the execution trace.
    Cell(CellVar),
}

/// A variable in a program can have different shapes.
pub enum VarKind {
    /// We pack [Const] and [CellVar] in the same enum because we often branch on these.
    ConstOrCell(ConstOrCell),

    /// A struct is represented as a mapping between field names and other [VarKind]s.
    Struct(HashMap&lt;String, VarKind&gt;),

    /// An array or a tuple is represented as a list of other [VarKind]s.
    ArrayOrTuple(Vec&lt;VarKind&gt;),
}

/// Represents a variable in the noname language, or an anonymous variable during computation of expressions.
pub struct Var {
    /// The type of variable.
    pub kind: VarKind,

    /// The span that created the variable.
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="var.html#admonition-note"></a>
</div>
<div>
<p>Note: see the <a href="./constants.html">Constant chapter</a> to see why constants are treated differently.</p>
</div>
</div>
<h2 id="anonymous-variable"><a class="header" href="#anonymous-variable">Anonymous variable</a></h2>
<p>Here’s a short note on anonymous variable.</p>
<p>When circuit writer parses the <a href="./compilation.html">ast</a>, it will convert each expression into a <code>Var</code> (unless the expression does not compute to an actual value).</p>
<p>In our example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = t + (z + y);
<span class="boring">}</span></code></pre></pre>
<p>the <code>z + y</code> is parsed as an expression (a binary operation involving <code>z</code> and <code>y</code>) and stored under a var <code>var1</code>.
Then <code>t + ...</code> is also parsed as another binary operation expression and stored under another var <code>var2</code>.
Finally the <code>let x = ...</code> is parsed as an assignment statement, and <code>x</code> is stored as a local variable associated to the right handside var <code>var2</code>.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="var.html#admonition-note-1"></a>
</div>
<div>
<p>See the <a href="./scope.html">Scope chapter</a> for more information on local variables.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-1"><a class="header" href="#constants-1">Constants</a></h1>
<p>Developers write constants in their code all the time. For example, the following code has two constants <code>2</code> and <code>4</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2 + y;
assert_eq(x, 4);
<span class="boring">}</span></code></pre></pre>
<p>It is important that constants are tracked differently than <code>CellVar</code>s for several reasons:</p>
<ul>
<li>It is sometimes useless to constrain them directly. For example, in <code>let x = 3 + 7;</code> you can see that we should not constrain <code>3</code> and <code>7</code> separately, but rather the result <code>10</code>.</li>
<li>It is sometimes useless to constrain them at all. For example, boolean constants are never constrained because you never need to.</li>
<li>They can be cached to avoid creating several constraints for the same constant.</li>
</ul>
<p>Currently a constant appears in the circuit only when <code>CircuitWriter::add_constant</code> is called.
It uses the generic gate to constrain the value, and is not cached (so calling it several times with the same constant will create multiple constraints):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_constant(&amp;mut self, value: Field, span: Span) -&gt; CellVar {
    let var = self.new_internal_var(Value::Constant(value), span);

    let zero = Field::zero();
    self.add_gate(
        GateKind::DoubleGeneric,
        vec![Some(var)],
        vec![Field::one(), zero, zero, zero, value.neg()],
        span,
    );

    var
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the <code>Value</code> keeps track of the constant as well.</p>
<p>Warning: gadgets must all handle constants gracefully.
That is, they must constrain constants themselves (by calling <code>CircuitWriter::add_constant</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-environment"><a class="header" href="#global-environment">Global environment</a></h1>
<p>In this chapter we will talk about functions.</p>
<h2 id="local-functions"><a class="header" href="#local-functions">Local functions</a></h2>
<p>Third-party libraries can have function names that collide with your own function names.
Due to this, they are tracked in a different data structure that we will see later.</p>
<p>Local functions include:</p>
<ul>
<li><strong>automatically imported built-ins</strong>. Think functions like <code>assert</code> and <code>assert_eq</code>. See <a href="./basics.html#Builtins-and-use-statements">here</a> for a full list.</li>
<li><strong>main</strong>, this is the main function that your program runs. Of course if you’re writing a library this function is not present.</li>
<li><strong>normal functions</strong>, these are functions that you define in your program. They can be recursive.</li>
<li><strong>methods</strong>, these are functions that are defined on a type. They can be recursive as well.</li>
</ul>
<p>Built-ins are different from all other functions listed because they are not written in noname, but written in Rust within the compiler.</p>
<p>For this reason we track functions according to this enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FnKind {
    /// signature of the function
    BuiltIn(FnHandle),

    /// Any function declared in the noname program (including main)
    LocalFn(AST)

    /// path, and signature of the function
    Library(Vec&lt;String&gt;),
}

/// An actual handle to the internal function to call to resolve a built-in function call.
pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub struct FnInfo {
    pub name: Ident,
    pub sig: FnSig,
    pub kind: FnKind,
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the signature of a <code>FnHandle</code> is designed to:</p>
<ul>
<li><code>&amp;mut CircuitWriter</code>: take a mutable reference to the circuit writer, this is because built-ins need to be able to register new variables and add gates to the circuit</li>
<li><code>&amp;[Var]</code>: take an unbounded list of variables, this is because built-ins can take any number of arguments, and different built-ins might take different types of arguments</li>
<li><code>Span</code>: take a span to return user-friendly errors</li>
<li><code>-&gt; Result&lt;Option&lt;Var&gt;&gt;</code>: return a <code>Result</code> with an <code>Option</code> of a <code>Var</code>. This is because built-ins can return a variable, or they can return nothing. If they return nothing, then the <code>Option</code> will be <code>None</code>. If they return a variable, then the <code>Option</code> will be <code>Some(Var)</code>.</li>
</ul>
<p>We track all of these functions in the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    functions: HashMap&lt;String, FnInfo&gt;,

    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-builtins"><a class="header" href="#handling-builtins">Handling builtins</a></h2>
<p>Builtins are handled in a special way. They are not written in noname, but in Rust.</p>
<h2 id="handling-local-functions"><a class="header" href="#handling-local-functions">Handling local functions</a></h2>
<p>The parser:</p>
<ul>
<li>saves the AST of each function it encounters. Specifically, the function’s AST is stored under the <code>GlobalEnv</code> (TODO: where exactly?). This is necessary as the circuit writer will have to switch to a function’s AST when a function is called (and then return to its own AST).</li>
</ul>
<p>The first step of the type checker resolves imports by doing the following:</p>
<ul>
<li>store all built-ins in the <code>functions</code> map of the <code>GlobalEnv</code></li>
<li>resolve all imports (e.g. <code>use std::crypto</code>)</li>
<li>type check each function individually, and save their signature in the <code>GlobalEnv</code> using the <code>FnSig</code> type</li>
<li>type check function calls with the signatures they just saved</li>
</ul>
<p>(TODO: this means that function declaration must be ordered. I think it is a GOOD thing)</p>
<p>When a function is called, we do the following:</p>
<ul>
<li>if the function is qualified (e.g. <code>crypto::poseidon</code>), then lookup imported modules (see next section)</li>
<li>otherwise, check if the function exists in the <code>GlobalEnv</code>, if it doesn’t then return an error</li>
<li>if the function exists, then create a new <code>FnEnv</code> and register the arguments as local variables there</li>
<li>switch to the function’s AST and pass the new <code>FnEnv</code> as argument</li>
<li>TODO: how to handle the return value? it should be saved in the <code>FnEnv</code></li>
</ul>
<h2 id="third-party-libraries"><a class="header" href="#third-party-libraries">Third-party libraries</a></h2>
<p>TODO: write this part</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This seems to be used by both the type checker and the AST
// TODO: right now there's only one scope, but if we want to deal with multiple scopes then we'll need to make sure child scopes have access to parent scope, shadowing, etc.
#[derive(Default, Debug)]
pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,

    /// the arguments expected by main
    pub main_args: (HashMap&lt;String, FuncArg&gt;, Span),
}

pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub enum FuncInScope {
    /// signature of the function
    BuiltIn(FnSig, FnHandle),

    /// path, and signature of the function
    Library(Vec&lt;String&gt;, FnSig),
}
<span class="boring">}</span></code></pre></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="functions.html#admonition-note"></a>
</div>
<div>
<p>Not all modules are third-party libraries, some are also built-ins (e.g. <code>std::crypto</code>).</p>
</div>
</div>
<p>As part of resolving imports, the type checker looks at third-party libraries differently…</p>
<p>TODO: implement this</p>
<p>TODO: how to handle diamond dependency graph or cycles? We must form a dependency graph first, and resolve dependency according to this graph</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-1"><a class="header" href="#scope-1">Scope</a></h1>
<p>Like most languages, noname has a notion of scope within a function.
Unlike a lot of languages noname forbids shadowing at all scope level.
This means that even though different functions can use local variable with colliding names, the local variable of one function must all have different names.</p>
<p>For example, the following code does not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = 3; // this won't compile

let y = 4;
for i in 0..4 {
    let y = i; // this won't compile either
}
<span class="boring">}</span></code></pre></pre>
<p>Scopes are only used for:</p>
<ul>
<li>for loops</li>
<li>in the future: if/else statements</li>
</ul>
<h2 id="scope-mechanisms"><a class="header" href="#scope-mechanisms">Scope mechanisms</a></h2>
<p>Both the type checker and the circuit writer need to keep track of local variable.
For the type checker (<code>type_checker.rs</code>), a <code>TypeEnv</code> structure keeps track of the association between all local variables names and their type information.
For the circuit writer (<code>circuit_writer.rs</code>), a <code>FnEnv</code> structure keeps track of the association between all local variable names and their circuit variable.</p>
<p>Both structures also keep track of how nested the current block is (the top level starting at level 0).
For this reason, it is important to remember to increase the current scope when entering a new block (for loop, if statement, etc.) and to decrease it when exiting the block.
In addition, all variables from a scope must be disabled (but not deleted, in order to detect shadowing) when exiting that scope.</p>
<p>For example, the type checker’s <code>TypeEnv</code> structure implements the following logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypeEnv {
    // ...


    /// Enters a scoped block.
    pub fn nest(&amp;mut self) {
        self.current_scope += 1;
    }

    /// Exits a scoped block.
    pub fn pop(&amp;mut self) {
        self.current_scope.checked_sub(1).expect("scope bug");

        // disable variables as we exit the scope
        for (name, (scope, type_info)) in self.vars.iter_mut() {
            if *scope &gt; self.current_scope {
                type_info.disabled = true;
            }
        }
    }

    /// Returns true if a scope is a prefix of our scope.
    pub fn is_in_scope(&amp;self, prefix_scope: usize) -&gt; bool {
        self.current_scope &gt;= prefix_scope
    }

    /// Stores type information about a local variable.
    /// Note that we forbid shadowing at all scopes.
    pub fn store_type(&amp;mut self, ident: String, type_info: TypeInfo) -&gt; Result&lt;()&gt; {
        match self
            .vars
            .insert(ident.clone(), (self.current_scope, type_info.clone()))
        {
            Some(_) =&gt; Err(Error::new(
                 ErrorKind::DuplicateDefinition(ident),
                 type_info.span,
            )),
            None =&gt; Ok(()),
        }
    }

    /// Retrieves type information on a variable, given a name.
    /// If the variable is not in scope, return false.
    pub fn get_type_info(&amp;self, ident: &amp;str) -&gt; Option&lt;TypeInfo&gt; {
        if let Some((scope, type_info)) = self.vars.get(ident) {
            if self.is_in_scope(*scope) &amp;&amp; !type_info.disabled {
                Some(type_info.clone())
            } else {
                None
            }
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-outputs"><a class="header" href="#public-outputs">Public Outputs</a></h1>
<p>Public outputs are usually part of the public inputs in Plonk.</p>
<p>In noname, public outputs are treated differently than the public inputs for one reason: unlike (real) public inputs they cannot be computed directly during witness generation (proving).</p>
<p>This is because public inputs are listed first in the circuit. During witness generation, we go through each rows and evaluate the values of the cells to construct the execution trace.
When we reach the public output part of the public input, we do not yet have enough information to construct the values.
Thus, we ignore them, and fill them later on.</p>
<p>During the compilation, we create <code>CellVars</code> to keep track of the public output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// If a public output is set, this will be used to store its [CircuitVar] (cvar).
    /// The public output generation works as follows:
    /// 1. This cvar is created and inserted in the circuit (gates) during compilation of the public input
    ///    (as the public output is the end of the public input)
    /// 2. When the `return` statement of the circuit is parsed,
    ///    it will set this `public_output` variable again to the correct vars.
    /// 3. During witness generation, the public output computation
    ///    is delayed until the very end.
    pub public_output: Option&lt;CellVars&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>During witness generation (see the <a href="./witness-generation.html">Witness Generation chapter</a>), we indeed defer computation the first time we go through the public output rows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = if let Some(var) = var {
    // if it's a public output, defer its computation
    if matches!(self.vars_to_value[&amp;var], Value::PublicOutput(_)) {
        public_outputs_vars.push((row, *var));
        Field::zero()
    } else {
        self.compute_var(&amp;mut env, *var)?
    }
} else {
    Field::zero()
};
witness_row[col] = val;
<span class="boring">}</span></code></pre></pre>
<p>and at the end we go back to them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// compute public output at last
let mut public_output = vec![];

for (row, var) in public_outputs_vars {
    let val = self.compute_var(&amp;mut env, var)?;
    witness[row][0] = val;
    public_output.push(val);
}
<span class="boring">}</span></code></pre></pre>
<p>and finally we return the public output to the prover so that they can send it to the verifier, as well as the “full public input” which is the concatenation of the public input and the public output (needed to finalized the proof):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// return the public output separately as well
Ok((Witness(witness), full_public_inputs, public_output))
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witness-generation"><a class="header" href="#witness-generation">Witness Generation</a></h1>
<p>Witness generation is the process of creating the execution trace table during proving.
The execution trace table is then passed to the <a href="">kimchi</a> proof system which will create the final proof.</p>
<p>The code creates a series of instructions during compilation for the witness generation to follow.
These instructions are stored as two different fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// This is how you compute the value of each variable, for witness generation.
    pub vars_to_value: HashMap&lt;CellVar, Value&gt;,

    // ...

    /// This is used to compute the witness row by row.
    pub witness_table: Vec&lt;Vec&lt;Option&lt;CellVar&gt;&gt;&gt;,

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>witness_table</code> can essentially be seen as the execution trace table, containing variables instead of values.</p>
<p>The witness generation goes as follows:</p>
<ol>
<li>Each row in <code>witness_table</code> is looked at one by one</li>
<li>For each <code>CellVar</code> in the row:
<ol>
<li>If it is set, it is evaluated using the <code>Value</code> stored in <code>vars_to_value</code>.</li>
<li>If it set to <code>None</code>, it is simply evaluated as <code>0</code>.</li>
</ol>
</li>
<li>Once the row is created, it is checked for correctness by checking what gate was used in the row. Note that this is only true for the generic gate, as we trust built-in gadgets to produce correct values. For example, <code>assert(x, 2)</code> will be checked because it is using the generic gate, but <code>let y = poseidon(x)</code> won’t be because we trust the poseidon gate to be correct (and if there is a bug there, kimchi will still catch it).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0-generic-sized-arrays-in-function-signatures"><a class="header" href="#rfc-0-generic-sized-arrays-in-function-signatures">RFC-0: Generic-sized arrays in function signatures</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This RFC proposes to support const generics in noname. The generic parameters can be resolved from the observed arguments, such as constants, arrays, or structs. This improves reusability and modularity of the code. It is a prerequisite for supporting generic array with symbolic size.</p>
<h2 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h2>
<p>Here is a few previews of how the generic parameters can be used, and what features it would unlock.</p>
<p>Allow functions to create array with symbolic size:</p>
<pre><pre class="playground"><code class="language-rust">// the return type is determined by the generic arguments
// so `init_arr` can be used to create arrays with different sizes
fn init_arr(const LEN: Field) -&gt; [Field; LEN] {
    let arr = [0; LEN];
    return arr;
}


fn main() -&gt; [Field; 3] {
    let arr = init_arr(3);
    return arr;
}</code></pre></pre>
<p>Resolving the generic values from the observed array argument:</p>
<pre><pre class="playground"><code class="language-rust">fn last(arr: [Field; LEN]) -&gt; Field {
    // use generic parameter LEN to form dynamic expressions in the function scope
    return arr[LEN - 1];
}

fn main() -&gt; Field {
    let arr = [1, 2, 3, 4, 5];
    // generic parameter LEN can be resolved from the array size of argument `arr`
    return last(arr);
}
</code></pre></pre>
<h2 id="builtin-examples"><a class="header" href="#builtin-examples">Builtin Examples</a></h2>
<p>Given the following function signatures for builtin functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_bits(const LEN: Field, val: Field) -&gt; [Field; LEN]
fn from_bits(bits: [Bool; LEN]) -&gt; Field
<span class="boring">}</span></code></pre></pre>
<p>Calling the builtin functions in native code:</p>
<pre><pre class="playground"><code class="language-rust">use std::bits;

const num_bits = 8;

fn main() {
    let val1 = 101;
    // `num_bits` will be assigned to the generic parameter `LEN` in the return type
    // then the type of `bits` will be monomorphized to [Bool; 8]
    let bits = bits::to_bits(num_bits, val); 
    // the value of `LEN` can be determined from the size of `bits` during monomorphization
    // so the builtin function knows how many bits to convert
    let val2 = bits::from_bits(bits); 
    assert_eq(val1, val2);
}</code></pre></pre>
<p>The values for the generic parameters will be passed to the function via the <code>generics</code> argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_bits&lt;B: Backend&gt;(
    compiler: &amp;mut CircuitWriter&lt;B&gt;,
    generics: &amp;GenericParameters,
    vars: &amp;[VarInfo&lt;B::Field, B::Var&gt;],
    span: Span,
) -&gt; Result&lt;Option&lt;Var&lt;B::Field, B::Var&gt;&gt;&gt; {
    ...

    // retrieve the generic values from the `generics` argument
    let bitlen = generics.get("LEN") as usize;

    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Both the return type and returned vars can be checked outside of the builtin functions. The return type can be checked automatically in the same way as the native functions, the types of which are propagated and converged at certain point, at which error will be thrown if the types are not matched.</p>
<p>The return vars can be checked by relying on the types. Each concrete type has a fixed number of vars. With the resolved return type of the builtin function, we can check if the size is matched. Additionally, we can check the values recursively with the type structure, but it might only limited to checking the boolean type which got obvious bound 0 or 1. So automatically checking if the actual return from a builtin is an area to be improved in the future.</p>
<h2 id="monomorphization"><a class="header" href="#monomorphization">monomorphization</a></h2>
<p>The resolving of the generic values can be done by observing the arguments passed to the function. Then it stores the resolved values in the relevant contexts for the following compiler pipeline to do type checking and circuit synthesizing. We call the process of resolving the generic values and type checking <em>Monomorphization</em>.</p>
<p>The current pipeline of compiling noname code is:</p>
<ol>
<li>Parse the code into AST</li>
<li>Convert the AST into NAST with naming resolution</li>
<li>Convert the NAST into TAST with type metadata collection and type checking</li>
<li>Circuit synthesizing TAST into an constraint system</li>
</ol>
<p>With generic parameters, the current TAST phase can’t handle the type checking anymore, because the generic parameters are unknown. For example, it can’t type check the array with symbolic size without resolving the values for the generic parameters.</p>
<p>To extend the type checking to support generic parameters, we can add a MAST phase (Monomorphized AST), right after the TAST phase, to resolve the values of the generic parameters. The circuit synthesizer will rely on the MAST instead of the TAST to compile a circuit.</p>
<p>Below is the diagram of the compiler pipeline with the MAST phase added:
<img src="rfc//book/src/assets/compiler-pipeline.png" alt="pipeline" /></p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>To support the generic syntax as shown in the examples above, we need to make changes to the AST Parser support generic syntax. Furthermore, because the generic parameters can’t be resolved at TAST phase, the some type checkings will be less strict and deferred to MAST phase.</p>
<p>Here is a list of cases where the type checks can’t be done at TAST phase, as they need to resolve the generic values:</p>
<ol>
<li>Inconsistent sizes of arrays with same generic parameters</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn gen(const LEN: Field) -&gt; [Field; LEN] {
    return [0; LEN];
}

// expect same generic size
fn comp(arr1: [Field; LEN], arr2: [Field; LEN]) {
    for ii in 0..LEN {
        assert_eq(arr1[ii], arr2[ii]);
    }
}

fn main(pub xx: Field) {
    let arr1 = gen(2);
    let arr2 = gen(3);
    // arrays with different sizes
    comp(arr1, arr2); 
}</code></pre></pre>
<ol start="2">
<li>Assignment type mismatched</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn gen(const LEN: Field) -&gt; [Field; LEN] {
    return [0; LEN];
}

fn main(pub xx: Field) {
    let mut arr = [0; 3];
    // arrays with different sizes
    arr = gen(2);
}</code></pre></pre>
<ol start="3">
<li>Custom type field mismatched</li>
</ol>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    xx: [Field; 2],
}

fn gen(const LEN: Field) -&gt; [Field; LEN] {
    return [0; LEN];
}

fn main(pub xx: Field) {
    let arr = gen(3);
    // array size mismatched
    let thing = Thing { xx: arr };
}</code></pre></pre>
<ol start="4">
<li>Array index out of bounds</li>
</ol>
<pre><pre class="playground"><code class="language-rust">fn gen(const LEN: Field) -&gt; [Field; LEN] {
    return [0; LEN];
}
fn main(pub xx: Field) {
    let arr = gen(3);
    // 3 is out of bounds
    arr[3] = 1;
}</code></pre></pre>
<p>The newly added phase MAST will be responsible for resolving the generic values from the observed arguments. It includes type checking on the monomorphized types that are bypass in the TAST phase.</p>
<h3 id="generic-syntax"><a class="header" href="#generic-syntax">Generic Syntax</a></h3>
<p>This RFC proposes a simple generic syntax without the introduction of the common turbofish syntax, since we don’t need to resolve the generic parameters from the function arguments. Instead, the values of the generic parameters can be directly resolved by comparing values with the observed arguments.</p>
<p>For example, with the turbofish, we could do something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_arr&lt;N&gt;(arr: [Field; N + 3]) -&gt; [Field; N + 3] {...}
<span class="boring">}</span></code></pre></pre>
<p>This is a rare case where the generic parameter can’t be trivially resolved from the observed arguments. To get it work without any advanced inference setups, it would require manually passing the value of <code>N</code> to the function via turbofish syntax, such as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a is then of type [Field, 6]
let a = create_arr::&lt;3&gt;(arr);
<span class="boring">}</span></code></pre></pre>
<p>However, for most of the cases, the values for the generic parameters can be obtained simply by observing the arguments passed to the function. This RFC aims to keep the syntax simple and to be intuitive. Without the turbofish syntax, the generic syntax can be simplified like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the value of LEN equals to the argument passed in
fn create_arr(const LEN: Field) -&gt; [typ; LEN]

// if the argument is array, then the value of LEN equals to the size of the array
fn last(arr: [typ; LEN]) -&gt; Field
<span class="boring">}</span></code></pre></pre>
<p>In the function scope, it might need to determine whether a variable is a generic parameter or not. We rules strings with at least 2 letters, which should be all capitalized, as generic parameters.</p>
<h3 id="ast-parser"><a class="header" href="#ast-parser">AST Parser</a></h3>
<p>Parser will need to collect the generic identifiers for the following constructions <code>FunctionDef</code>. It will add a new <code>TyKind</code>, the <code>GenericSizedArray(type, size)</code>. The size of <code>GenericSizedArray</code> is represented by a <code>Symbolic</code> value, which can contain generic parameters or concrete values.</p>
<p>We add <code>generics</code> field to <code>FunctionDef</code>, which is a set of <code>GenericParameters</code> mapping between generic names and values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Symbolic {
    Concrete(u32), // literal value
    Generic(GenericParameters), // generic parameters
    Constant(Ident), // pointing to a constant variable
}

GenericSizedArray {
    ty: TyKind,
    size: Symbolic,
}
<span class="boring">}</span></code></pre></pre>
<p>Update <code>FunctionDef</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FunctionDef {
    ...
    // to add
    pub generics: HashSet&lt;GenericIdentifier&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Example for a function with a generic parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_arr(const LEN: Field) -&gt; [Field; LEN] {...}
<span class="boring">}</span></code></pre></pre>
<p>The parser should create the function definition like pseudo code below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FunctionDef{
    FnSig = {
        ...
        generics = {"LEN": null},
        FnArg = {
            name: 'LEN', 
        }
        // Add / Mul / Generic / Concrete are variants of Symbolic enum
        return_type: GenericSizedArray(Field, Generic("LEN"))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The TAST use these metadata of generic parameters for type checking the consistency of generic identifiers. In MAST phase, they will be useful for resolving the generic values from the observed arguments.</p>
<h3 id="tast"><a class="header" href="#tast">TAST</a></h3>
<p>The generic values are resolved from the observed arguments. If the generic parameters are declared, they should be used in the function body. We need to check if the generic parameters declared make senses.</p>
<p><em>Type check generic parameters for functions</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// shouldn't allow this, because the LEN should be defined in the function arguments
fn foo(n: Field) -&gt; [Field; LEN] {...}

// not allowed if no use of NN in the body
fn foo(const NN: Field) {...} 
fn foo(arr: [Field; NN]) {...} 
<span class="boring">}</span></code></pre></pre>
<p><em>Restrictions over generic function in for-loop</em>
<strong>Mutable Variables as Generic Arguments</strong>: It’s prohibited to use mutable variables as generic arguments in generic function calls inside loops. The language doesn’t support loop unrolling, so using loop indices or mutable counters as generic parameters is invalid.</p>
<p>Invalid example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_call(const LEN: Field) -&gt; [Field; LEN] {...}

...
for ii in 0..NN {
    fn_call(ii); // Error: 'ii' is mutable
}

...
let mut jj = 0;
for ii in 0..NN {
    fn_call(jj); // Error: 'jj' is mutable
    jj = jj + 1;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Allowed Usage with Constants</strong>: You can use constant values or immutable variables as generic arguments within loops.</p>
<p>Valid example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let kk = 0;
for ii in 0..NN {
    fn_call(kk); // Allowed: 'kk' is constant
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Exception for Arrays</strong>: Mutable array variables can be used as generic arguments because their sizes are fixed at declaration, even if their contents change.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fn_call_arr(const arr: [Field; LEN]) -&gt; [Field; LEN] {...}
...

let mut arr = [0; 3];
for ii in 0..NN {
    fn_call_arr(arr); // Allowed: array size is fixed
}
<span class="boring">}</span></code></pre></pre>
<p><em>Forbid operations on symbolic value of arguments</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// disallow arithmetic operations on the symbolic value of the function arguments,
// such as NN * 2 in this case.
// because it is challenging to resolve the value of NN.
fn last(arr: [Field; NN * 2]) -&gt; Field {
    return arr[NN - 1];
}
<span class="boring">}</span></code></pre></pre>
<p><em>Defer type checks</em>
Anything involves the generic parameters should be deferred to MAST phase. We need to defer the type checks for array with generic size.</p>
<p>In MAST phase, the values of generic parameters can be resolved, so the symbolic values can be evaluated. Thus, all the types with generic parameters can be type checked, as the array sizes become concrete values.</p>
<h3 id="mast"><a class="header" href="#mast">MAST</a></h3>
<p>After the TAST phase, the MAST phase can resolve the generic values from the observed arguments by propagate the constant values through the main function AST.</p>
<h3 id="resolving-algorithm"><a class="header" href="#resolving-algorithm">Resolving algorithm</a></h3>
<p>The algorithm will need to handle the following two categories:</p>
<ul>
<li>Resolving from constant argument</li>
<li>resolving from array argument</li>
</ul>
<p>Example of resolving constant arguments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// constant generic
// - the value of LEN can be resolved from an observed constant value propagated
// - store the value in the function body scope
fn gen_arr(const LEN: Field) -&gt; [Field; LEN] {
    let arr = [Field; LEN];
    return arr;
}
<span class="boring">}</span></code></pre></pre>
<p>Example of resolving from array arguments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First, here is a simple case.
// - the LEN can be resolved from the array size of argument `arr` 
// - store the value of N in the context
fn last(arr: [Field; LEN]) -&gt; Field {
    return arr[LEN - 1];
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Then, here is a more challenging case that would require techniques like SMT to solve the unique values of the generic parameters.
// Even LEN * 2 looks obvious to solve, solving it may need something like (computer algebra system) CAS in rust.
// It is easy to evaluate the Symbolic values using the solved generic value. But the way around is difficult.
fn last(arr: [Field; LEN * 2]) -&gt; Field {
    return arr[LEN - 1];
}
<span class="boring">}</span></code></pre></pre>
<p>In this RFC, we want to just enforce the syntax to be sufficient to support the simple cases. That is to disallow arithmetic operations among generic parameters for function arguments.</p>
<p>To recap, here is the pseudo code for the resolving algorithm for function:</p>
<ol>
<li>Collect the observed arguments</li>
<li>For each argument, resolve the generic values from the observed arguments</li>
<li>For each statement, compute the type with the resolved generic values</li>
<li>Type check the resolved type being returned with the expected return type</li>
</ol>
<h3 id="function-call-instantiation"><a class="header" href="#function-call-instantiation">Function Call Instantiation</a></h3>
<p>The functions are defined as <code>FunctionDef</code>, which is an AST containing the signature and the body of the function. The body is a vector of statements, each of which is a tree of expression nodes. It is fine to have different function calls pointing to these functions’ original AST, when the content of these functions doesn’t change, and so are the expression nodes.</p>
<p>However, when a function takes generic arguments, the actual arguments can result in different expression nodes. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn last(arr: [Field; LEN]) -&gt; Field {
    return arr[LEN - 1];
}

fn main() {
    let arr1 = [1, 2, 3, 4, 5];
    let arr2 = [6, 7, 8, 9];

    let last1 = last(arr1); // with LEN = 5
    let last2 = last(arr2); // with LEN = 4
}</code></pre></pre>
<p>The monomorphized body of the function call for <code>last(arr1)</code> is <code>return arr[5 - 1]</code>, while the one for <code>last(arr2)</code> is <code>return arr[4 - 1]</code>. Therefore, we can’t have a single expression node representing both <code>arr[5 - 1]</code> and <code>arr[4 - 1]</code> expression nodes. These functions should be instantiated with new ASTs, which are monomorphized from the original ASTs. They will be regenerated with the generic parameters being resolved with concrete values. The two calls to <code>last</code> should point to two different monomorphized function instances.</p>
<p>To ensure no conflicts in the node IDs being regenerated for these instantiated functions, the AST for the main function as an entry point will be regenerated. The monomorphized AST preserves the span information to point to the noname source code for the existing debugging feature.</p>
<p>Same as before, these instantiated functions can be pointed by the expression nodes <code>ExprKind::FnCall</code>. With the support of generic parameters, we need to change the way of loading the function AST, as the current fully qualified name pattern doesn’t contain the information to differentiate the instantiated functions with different generic values.</p>
<p>Thus we can generate the monomorphized function name, and use it to store the monomorphized function AST instead of the original function name. The new string pattern to store the monomorphized function AST can be:
<code>fn_full_qualified_name#generic1=value1#generic2=value2</code></p>
<p><em>Type checking</em>
The instantiation of a generic function will resolve the generic types to be concrete types. Similar to the TAST phase, during the monomorphization of a function body, the computed concrete type can be propagated and compared with the return type of the function signature.</p>
<p>The type check in this phase will always be in concrete type. Any unresolved generic type will fail the type check.</p>
<h3 id="monomorphization-process"><a class="header" href="#monomorphization-process">Monomorphization Process</a></h3>
<p>Here is an overview of the monomorphization process:</p>
<ol>
<li>
<p>Propagates types in the same way the type checker was doing but also with constant values, which will be used to resolve the generic parameters.</p>
</li>
<li>
<p>Along the way, it also propagates the AST nodes. When it is not part of a generic function, the node should remain the same. Otherwise, the node should be regenerated.</p>
</li>
<li>
<p>Whenever it encounters a generic function call, it instantiates the function based on the arguments and store it as a new function with a monomorphized name, then walks through the instantiated function AST. The function call AST node will be modified with the monomorphized name while retaining the same node id and span.</p>
</li>
<li>
<p>In the function instantiation process, all the AST nodes will be regenerated. This new AST will be stored under the monomorphized function name.</p>
</li>
<li>
<p>After monomorphized a function, it should add the name of the original function to a list that records which function AST to delete at the end. We can’t not delete the original function AST immediately, because it might be called at different places.</p>
</li>
<li>
<p>In each function block scope, it should type check the return types, by comparing the propagated return type and the defined return type. All these types should be in concrete form without generic parameters involved.</p>
</li>
<li>
<p>At the end, it overrides the main function AST with the monomorphized version, and delete generic functions based on the list.</p>
</li>
</ol>
<p>All the updates are done to the existing stores in the TAST.</p>
<ul>
<li>Instantiated functions are added to <code>HashMap&lt;FullyQualified, FnInfo&lt;B&gt;&gt;</code>.</li>
<li>Types for Monomorphized nodes are stored in <code>HashMap&lt;usize, TyKind&gt;</code> (Keep in mind the store for node types <code>HashMap&lt;usize, TyKind&gt;</code> can also contain the node types for the deleted functions. We may need to figure out a way to safely delete the node types belonging to a deleted function)</li>
<li>Generic functions should be delete from <code>HashMap&lt;FullyQualified, FnInfo&lt;B&gt;&gt;</code></li>
</ul>
<h3 id="circuit-synthesizer"><a class="header" href="#circuit-synthesizer">Circuit Synthesizer</a></h3>
<p>Circuit synthesizer will rely on the monomorphized AST to compile the circuit. To synthesizer, the workflow will be the same as before, but with the monomorphized AST. It doesn’t need to be aware of the newly added support related to generics. The added MAST phase simplifies what needs to be done in the circuit synthesizer to support the generic features, in comparison to the alternative approach described in the following section.</p>
<h2 id="alternative-approach"><a class="header" href="#alternative-approach">Alternative approach</a></h2>
<p><a href="https://github.com/zksecurity/noname/pull/136">One alternative approach</a> to the monomorphization described above is to propagate the generic values directly in circuit writer, without the need to add the MAST phase.</p>
<p>The circuit writer walks through the original AST via the <code>compile_expr</code> function. This function propagate the values from the main function argument and constants and compute the <code>VarOrRef</code> as an result. The <code>VarOrRef</code> doesn’t return the struture of the types being computed.</p>
<p>In the process, when it needs to determine the structure of the type behind an expression node, it relies on the <code>size_of</code> function to determine the number of vars representing the type. The <code>size_of</code> relies on the node id of an expression to look up the type. This is not a problem when the types are concrete.</p>
<p>When the type behind an expression node is generic, the way of looking up the size of a type via <code>size_of</code> is not applicable anymore, since the expression node can be of a generic type.</p>
<p>To solve this problem, there should be a new way to determine the size of a type for an expression node without relyin on the node id. One way, described <code>ComputedExpr</code>, is to retain the structure of the type through the propagation in <code>compute_expr</code>. Instead of passing around the <code>VarOrRef</code>, the <code>compute_expr</code> returns <code>ComputedExpr</code> which contains both the structure of the type and the underlying variables <code>VarOrRef</code>.</p>
<p>For example, when it is computing for the <code>ExprKind::ArrayAccess</code>, it can use the <code>ComputedExpr</code> of the <code>array</code> expression node to determine the size of the array, so as to do some bound checks for access index.</p>
<p>This approach would require a significant refactor of the circuit writer’s compilation process. It would require changes to the assumptions from using <code>VarOrRef</code> to structured <code>ComputedExpr</code>. It would also need to rely on <code>ComputedExpr</code> to do some addtional checks instead of just relying on types. This would require quite a number of additional assumptions between the <code>ComputedExpr</code>, the actual types and generic parameters.</p>
<p>Therefore, we thought the monomorphization approach is more straightforward and easier to maintain in a long run, considering the pipeline of the compiler.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
