<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>noname</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Language</li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">2.</strong> Basics</a></li><li class="chapter-item expanded affix "><li class="part-title">Compiler Internals</li><li class="chapter-item expanded "><a href="compilation.html"><strong aria-hidden="true">3.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="grammar.html"><strong aria-hidden="true">4.</strong> Grammar</a></li><li class="chapter-item expanded "><a href="spans.html"><strong aria-hidden="true">5.</strong> Spans</a></li><li class="chapter-item expanded "><a href="paths.html"><strong aria-hidden="true">6.</strong> Paths</a></li><li class="chapter-item expanded "><a href="type-checker.html"><strong aria-hidden="true">7.</strong> Type Checker</a></li><li class="chapter-item expanded "><a href="asm.html"><strong aria-hidden="true">8.</strong> Noname ASM</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">9.</strong> Structs</a></li><li class="chapter-item expanded "><a href="methods.html"><strong aria-hidden="true">10.</strong> Methods</a></li><li class="chapter-item expanded "><a href="literals.html"><strong aria-hidden="true">11.</strong> Literals and the const keyword</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">12.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">13.</strong> Modules</a></li><li class="chapter-item expanded affix "><li class="part-title">Circuit Generation</li><li class="chapter-item expanded "><a href="cellvar.html"><strong aria-hidden="true">14.</strong> CellVars</a></li><li class="chapter-item expanded "><a href="var.html"><strong aria-hidden="true">15.</strong> Vars</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">16.</strong> Constants</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">17.</strong> Functions</a></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">18.</strong> Scope</a></li><li class="chapter-item expanded affix "><li class="part-title">Proof Creation</li><li class="chapter-item expanded "><a href="public-outputs.html"><strong aria-hidden="true">19.</strong> Public Outputs</a></li><li class="chapter-item expanded "><a href="witness-generation.html"><strong aria-hidden="true">20.</strong> Witness Generation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">noname</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://www.github.com/mimoo/noname" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="noname"><a class="header" href="#noname">NoName</a></h1>
<p>This is the book on NoName, a high-level language to write circuits using the <a href="https://github.com/o1-labs/proof-systems">kimchi</a> zero-knowledge proof system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Noname is a language that closely resembles Rust.</p>
<p>For example, in the following program you can see a <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}</code></pre></pre>
<p>The only differences with Rust are:</p>
<ul>
<li>The <code>pub</code> keyword is used to mark <em>public</em> inputs. By default all arguments are private.</li>
<li><code>assert_eq</code> is not a macro, there are no macros in noname.</li>
<li>a <code>Field</code> type is used as main types everywhere. It is defined in <code>field.rs</code> to be the pasta Fp field (the base field of the Pallas curve). If these words mean nothing to you, just see <code>Field</code> as a large number. Ideally programs should be written without this type, but for now custom types do not exist.</li>
</ul>
<p>To run such a file, and assuming you have <a href="https://rustup.rs/">Rust</a> installed, you can type in the terminal:</p>
<pre><code>$ cargo run -- --path path/to/file.no --private-inputs '{"private_input": ["1"]}' --public-inputs '{"public_input": ["1"]}'
</code></pre>
<p>As you can see, inputs are passed with a JSON format, and the values are expected to be encoded in decimal numbers.</p>
<h2 id="builtins-and-use-statements"><a class="header" href="#builtins-and-use-statements">Builtins and use statements</a></h2>
<p>Some builtin functions are available by default:</p>
<ul>
<li><code>assert_eq</code> to check that two field elements are equal</li>
<li><code>assert</code> to check that a condition is true.</li>
</ul>
<p>Like in Rust, you can also import other libraries via the <code>use</code> keyword.
If you do this, you must know that you can only import a library, but not its functions (and types, and constants) directly.</p>
<p>For example, to use the poseidon function from the crypto library (or module), you must import <code>std::crypto</code> and then qualify your use of <code>crypto::poseidon</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::crypto;

fn main(pub public_input: Field, private_input: [Field; 2]) {
    let digest = crypto::poseidon(private_input);
    assert_eq(digest[0], public_input);
}</code></pre></pre>
<p>Note that currently, only built-in libraries (written in Rust) are working.
In the future we’d like for other libraries to be written in the noname language.</p>
<h2 id="field"><a class="header" href="#field">Field</a></h2>
<p>The <code>Field</code> type is the primitive type upon which all other types are built.
It is good to know about it as it is used in many places, and is error prone: it does not match the size of commonly-found types like <code>u32</code> and <code>u64</code> and can have unexpected behaviors as it can overflow or underflow  without emitting an error.</p>
<p>Ideally, you should never use the <code>Field</code> type, but currently the library is quite limited and the ideal world is far away.</p>
<p>Note that you can define <code>Field</code> elements directly in the code by writing a decimal number directly. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
assert(y, 4);
<span class="boring">}</span></code></pre></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>While there are no dynamic arrays (or vectors), you can use fixed-size arrays like in Rust.</p>
<p>For the moment, I believe that arrays can only be declared in a function argument as the following declaration hasn’t been implemented yet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, y];
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>Booleans are similar to Rust’s boolean. They are currently the only built-in type besides <code>Field</code> and arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = true;
let y = false;
assert(!(x &amp; y));
<span class="boring">}</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>Variables are by default not mutable. To make a variable mutable, you must use the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 1;
x = 2; // GOOD

let y = 1;
y = x + y; // BAD
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For loops</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: [Field; 3]) {
    let mut sum = 0;

    for i in 0..3 {
        sum = sum + private_input[i];
    }

    assert_eq(sum, public_input);
}</code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Like variables and function names, constants must be lowercase.</p>
<p>At the moment they can only represent field elements. Perhaps it would be nice to be able to represent different types in the future.</p>
<pre><pre class="playground"><code class="language-rust">const player_one = 1;
const player_two = 2;

fn main(pub player: Field) -&gt; Field {
    assert_eq(player_one, player);
    let next_player = player + 1;
    assert_eq(player_two, next_player);
    return next_player;
}</code></pre></pre>
<h2 id="if-else-statements"><a class="header" href="#if-else-statements">If Else statements</a></h2>
<p>Currently, if/else statements are not supported. Only the ternary operator is:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub xx: Field) {
    let plus = xx + 1;
    let cond = xx == 1;
    let yy = cond ? plus : xx ;
    assert_eq(yy, 2);
}</code></pre></pre>
<p>The two branches of the ternary operator must be variables (as in the xample), or array accesses (e.g. <code>thing[0]</code>), or field accesses (e.g. <code>thing.field</code>).</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><pre class="playground"><code class="language-rust">fn add(x: Field, y: Field) -&gt; Field {
    return x + y;
}

fn double(x: Field) -&gt; Field {
    return x + x;
}

fn main(pub one: Field) {
    let four = add(one, 3);
    assert_eq(four, 4);

    let eight = double(4);
    assert_eq(eight, double(four));
}</code></pre></pre>
<h2 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    x: Field,
    y: Field,
}

fn main(pub x: Field, pub y: Field) {
    let thing = Thing {
        x: 1,
        y: 2,
    };
    
    assert_eq(thing.x, x);
    assert_eq(thing.y, y);
}</code></pre></pre>
<h2 id="methods-on-custom-types"><a class="header" href="#methods-on-custom-types">Methods on custom types</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Thing {
    x: Field,
    y: Field,
}

fn Thing.new(x: Field, y: Field) -&gt; Thing {
    return Thing {
        x: x,
        y: y,
    };
}

fn Thing.verify(self, v: Field) {
    assert_eq(self.x, v);
    assert_eq(self.y, v + 1);
}

fn Thing.update_and_verify(self) {
    let new_thing = Thing {
        x: self.x + 1,
        y: self.y + 1,
    };

    new_thing.verify(2);
}

fn main(pub x: Field) {
    let thing = Thing.new(x, x + x);
    thing.update_and_verify();
}</code></pre></pre>
<p>technically you can even call static methods from a variable of that type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = thing.new(3, 4);
<span class="boring">}</span></code></pre></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="basics.html#admonition-note"></a></p>
</div>
<div>
<p>It’s not necessarily pleasant to read, and we could prevent it by storing some meta information (<code>static_method: bool</code>) in the type checker, but it’s not a big deal.</p>
</div>
</div>
<h2 id="early-returns"><a class="header" href="#early-returns">Early returns</a></h2>
<p>TODO</p>
<h2 id="hints"><a class="header" href="#hints">Hints</a></h2>
<p>TODO</p>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>We forbid variable shadowing as much as we can.</p>
<p>For example, this should not work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = 3; // this won't compile

let y = 4;
for i in 0..4 {
    let y = i; // this won't compile either
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<p>The compilation of noname programs goes through the following flow:</p>
<ol>
<li><strong>Lexer</strong>. A lexer (<code>lexer.rs</code>) is used to parse the source code into a list of tokens. This is pretty primitive, but will detect some minor syntax issues.</li>
<li><strong>Parser</strong>. A parser (<code>parser.rs</code>) is used to parse meaning from the code. It will convert the tokens output by the lexer into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a> using strong types like <a href=""><code>Statement</code></a> and <a href=""><code>Expression</code></a> (TODO: link to rust doc). It will also error if some code does not make sense according to the grammar (see the <a href="grammar.html">Grammar chapter</a>).</li>
<li><strong>Type checking</strong>. A type checker (<code>type_checker.rs</code>) takes the AST produced by the parser and does import resolution and type checking:
<ul>
<li><strong>Built-in functions</strong>. Functions like <code>assert_eq</code> are injected into the environment.</li>
<li><strong>Custom imports</strong>. Modules imported via the <code>use</code> keyword are resolved and added to the environment. For now, these can only be built-in functions, and noname functions or libraries are not supported (of course it is essential to support them in the future).</li>
<li><strong>Type checking</strong>. The type checker verifies that the types of each variables and expressions in the AST make sense. It is a very simple type checker that can do some simple type inference. Temporary type information (type of an expression) is not stored, and is thrown away as soon as the type checker can afford it. a TAST for typed AST is returned, but it mostly contains resolved imports and most type information has been thrown away.</li>
</ul>
</li>
<li><strong>Gate construction</strong>. The TAST produced by the type checker is passed to the circuit writer (<code>circuit_writer.rs</code>), also called the constraint writer, which goes through it one more time and converts it into:
<ul>
<li><strong>compiled circuit</strong>: a series of gates and wires</li>
<li><strong>prover instructions</strong>: instructions on how to run the function for the witness generation (used by the prover)</li>
</ul>
</li>
</ol>
<p>A simple ASM language is also used, and the circuit can be encoded in this language. See the <a href="asm.html">ASM chapter</a>.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>A note on topology:</p>
<ul>
<li><strong>functions</strong>: noname functions each contain their scope and can be interacted with their interface (arguments and return value)</li>
<li><strong>module/program</strong>: a noname module is a single file (this is a nice current limitation of noname) containing functions, constants, and structures.</li>
<li><strong>library</strong>: a noname library is a module/program without a <code>main()</code> function, as well as dependencies (other libraries)</li>
<li><strong>executable</strong>: a noname executable is like a library, except that its module/program has a <code>main()</code> function.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grammar"><a class="header" href="#grammar">Grammar</a></h1>
<p>The syntax of the noname language is described through its grammar.</p>
<p>We use a notation similar to the Backus-Naur Form (BNF)
to describe the grammar:</p>
<pre>
land := city "|"
 ^        ^   ^
 |        |  terminal: a token
 |        |
 |      another non-terminal
 |
 non-terminal: definition of a piece of code
city := [ sign ] "," { house }
        ^            ^
        optional     |
                    0r or more houses
sign := /a-zA-Z_/
        ^
        regex-style definition
</pre>
<p>There are some comments in the parser code (<code>parser.rs</code>) that attempt to define this grammar.</p>
<p>Essentially, it is made to look like Rust, but with some differences of philosophies:</p>
<ul>
<li>expressions cannot be statements, unless they return no value (act using side effects).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spans"><a class="header" href="#spans">Spans</a></h1>
<p>To be able to efficiently track errors, we have a span type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Span(pub usize, pub usize);
<span class="boring">}</span></code></pre></pre>
<p>which represents a location in the original source code:</p>
<ul>
<li>the first number is the offset in the source code file</li>
<li>the second number if the length of the span (e.g. 1 character)</li>
</ul>
<p>We start tracking spans in the lexer, and then pass them around to the parser, and then to the compiler. Even gates and wirings have spans associated with them so that we can easily debug those.</p>
<h2 id="filename"><a class="header" href="#filename">Filename</a></h2>
<p>The filename is currently missing from the <code>Span</code>, it is annoying to add it as a <code>String</code> because then we can’t easily copy the span around (<code>String</code> is not <code>Copy</code> but <code>Clone</code>).</p>
<p>One way to solve this, is to add the filenames in a <code>Hashmap&lt;usize, String&gt;</code>, and have the <code>usize</code> be in the <code>Span</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paths"><a class="header" href="#paths">Paths</a></h1>
<p>Paths are structures identifying snippets of code that look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>some_module::some_ident.stuff.z
<span class="boring">}</span></code></pre></pre>
<p>The identifier <code>some_module</code>, appearing before the <code>::</code>, is an optional module, pointing to code that exists in another library. It is always lowercase.</p>
<p>The identifier <code>some_ident</code> is mandatory. It can represent a type (if it starts with a capital letter), a function name, a variable name, a constant name, etc.</p>
<p>More identifiers can be concatenated together to form a longer path (using <code>.</code>).
A path is represent like this internally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A path represents a path to a type, a function, a method, or a constant.
/// It follows the syntax: `module::X` where `X` can be a type, a function, a method, or a constant.
/// In the case it is a method `a` on some type `A` then it would read:
/// `module::A.a`.
#[derive(Debug, Clone)]
pub struct Path {
    /// A module, if this is an foreign import.
    pub module: Option&lt;Ident&gt;,

    /// The name of the type, function, method, or constant.
    /// It's a vector because it can also be a struct access.
    pub name: Vec&lt;Ident&gt;,

    /// Its span.
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expressions-using-path"><a class="header" href="#expressions-using-path">Expressions using Path</a></h2>
<p>A path does not represent an expression by itself. The following expressions make use of <code>path</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExprKind {
    /// `module::some_fn()`
    FnCall {
        name: Path,
        args: Vec&lt;Expr&gt;,
    },

    /// `module::SomeType.some_method()`
    MethodCall {
        self_name: Path,
        method_name: Ident,
        args: Vec&lt;Expr&gt;,
    },

    /// `module::some_var` or
    /// `module::SomeType.some_field.some_other_field`
    Variable(Path),

    /// `module::SomeType.some_field[some_expr]` or
    /// `module::some_const[some_expr]`
    ArrayAccess {
        name: Path,
        idx: Box&lt;Expr&gt;,
    },

    /// `module::SomeType { field1: expr1; field2: expr2 }`
    CustomTypeDeclaration(Path, Vec&lt;(Ident, Expr)&gt;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-checker"><a class="header" href="#type-checker">Type Checker</a></h1>
<p>Noname uses a simple type checker to ensure that all types are consistent in the program.</p>
<p>For example, in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}</span></code></pre></pre>
<p>the type checker will ensure that <code>y</code> and <code>z</code> are both field elements (because the operation <code>+</code> is used).</p>
<p>And in code like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq(a, b);
<span class="boring">}</span></code></pre></pre>
<p>the type checker will ensure that <code>a</code> and <code>b</code> are of the same types, since they are being compared.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h2>
<p>The type checker can do some simple type inference. For example, in the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = y + z;
<span class="boring">}</span></code></pre></pre>
<p>the type of <code>x</code> is inferred to be the same as the type of <code>y</code> and <code>z</code>.</p>
<p>Inference is willingly kept naive, as more type inference would lead to less readable code.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The type checker must be aware of scopes, as it keeps track of the type of variables and functions that are local to each scope.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
for i in 0..2 {
    let y = x + 1; // x exists inside of this for loop
}
let z = 1 + y; // BAD: y doesn't exist outside of the for loop
<span class="boring">}</span></code></pre></pre>
<p>To do this, each function is passed an <a href="">Environment</a> which contains a list of all variables along with their type information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Environment {
    /// created by the type checker, gives a type to every external variable
    pub var_types: HashMap&lt;String, TypeInfo&gt;,

    // ...

    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>So that shadowing is disallowed, even in different scopes, there is only one variable that is stored, but the scope is stored in <code>TypeInfo</code> and matched against the current scope to see if the current scope is the same or a direct child.</p>
<p>An environment is unique to a function, as it is important that different functions can use the same variable names.</p>
<p>Some notes:</p>
<ul>
<li>Currently the notion of module is quite shaky. It is used mostly for <code>crypto::poseidon</code> at the moment.</li>
<li><code>functions</code> is mostly used for builtins like <code>assert_eq</code></li>
<li><code>modules</code> is mostly used for the functions in <code>std::crypto</code>, which only contains <code>crypto::poseidon</code> atm.</li>
</ul>
<p>more:</p>
<ul>
<li>I think Environment mixes things</li>
<li>we should be able to create a new Environment whenever we parse a new function, so the functions/modules should be part of another (AvailableToAllScopes)</li>
<li>variables is something that has nothing to do with the “Type” Environment and should be moved elsewhere no? GateCreationEnv?</li>
<li>there needs to be a namespace in the typeinfo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noname-asm"><a class="header" href="#noname-asm">noname ASM</a></h1>
<p>The circuit that noname compiles to can be serialized as a simple ASM language. For example the following noname program:</p>
<pre><pre class="playground"><code class="language-rust">fn main(pub public_input: Field, private_input: Field) {
    let x = private_input + public_input;
    assert_eq(x, 2);
}</code></pre></pre>
<p>will be compiled to the following noname asm:</p>
<pre><code>@ noname.0.5.0

DoubleGeneric&lt;1&gt;
DoubleGeneric&lt;1,1,-1&gt;
DoubleGeneric&lt;1,0,0,0,-2&gt;
DoubleGeneric&lt;1,-1&gt;
(0,0) -&gt; (1,1)
(1,2) -&gt; (3,1)
(2,0) -&gt; (3,0)
</code></pre>
<p>which includes:</p>
<ul>
<li><strong>the version</strong> of noname used to compile this circuit. This is important as the prover needs to know what version of noname to use to prove executions of this circuit.</li>
<li><strong>a list of gates</strong> and how they are tweaked (the values in the brackets).</li>
<li><strong>a list of wires</strong> which is canonically ordered so that every compilation gives the same resulting noname asm.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>User can define custom structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: Field,
    y: Field,
}
<span class="boring">}</span></code></pre></pre>
<p>and can declare and access such structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
let z = thing.x + thing.y;
<span class="boring">}</span></code></pre></pre>
<p>Internally, a struct is represented within the <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<h2 id="a-method-on-what"><a class="header" href="#a-method-on-what">A method on what?</a></h2>
<p>There’s one problem when handling methods in the circuit-writer: how do you know where the code of that method is? For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
let z = thing.valid(3);
<span class="boring">}</span></code></pre></pre>
<p>at this point the circuit-writer knows that <code>Thing</code> has a method called <code>valid</code>, but will still wonder what the type of <code>thing</code> is.</p>
<p>due to this, the circuit-writer needs to store the type of local variables in scope. And this is why <code>FnEnv</code> also keeps track of the type of local variables:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Is used to store functions' scoped variables.
/// This include inputs and output of the function,  as well as local variables.
/// You can think of it as a function call stack.
pub struct FnEnv {
    /// The current nesting level.
    /// Starting at 0 (top level), and increasing as we go into a block.
    current_scope: usize,

    /// Used by the private and public inputs,
    /// and any other external variables created in the circuit
    /// This needs to be garbage collected when we exit a scope.
    /// Note: The `usize` is the scope in which the variable was created.
    vars: HashMap&lt;String, (usize, VarInfo)&gt;,
}

/// Information about a variable.
#[derive(Debug, Clone)]
pub struct VarInfo {
    /// The variable.
    pub var: Var,

    /// We keep track of the type of variables, eventhough we're not in the typechecker anymore,
    /// because we need to know the type for method calls.
    pub typ: TyKind,
}
<span class="boring">}</span></code></pre></pre>
<p>This still doesn’t fix our problem. In the line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thing = Thing { x: 1, y: 2 };
<span class="boring">}</span></code></pre></pre>
<p>the local variable <code>thing</code> is stored, but the right hand side is computed via the <code>compute_expr()</code> function which will go through the AST and potentially create different anonymous variables until it can compute a value.</p>
<p>There’s three ways to solve this:</p>
<ol>
<li>Either the type checker stores type information about each expression it parses. This is what the Rust compiler does I believe: each <code>Expr</code> AST node has a unique node identifier that can be used to search type information in a map.</li>
<li>Or, more simply, the circuit-writer’s <code>compute_expr()</code> function that returns an <code>Option&lt;Var&gt;</code> could be modified to return <code>Option&lt;VarInfo&gt;</code>. This is a bit annoying as we’re recomputing things we’ve done in the type checker.</li>
<li>A variant of the previous option is to change <code>Var</code> so that it also contain a type (might as well).</li>
</ol>
<p>So we implement option 1: the type checker now stores the type information of each <code>Expr</code> node in the AST under a hashmap that is later passed to the circuit-writer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The environment we use to type check a noname program.
pub struct TypedGlobalEnv {
    // ...

    /// Mapping from node id to TyKind.
    /// This can be used by the circuit-writer when it needs type information.
    node_types: HashMap&lt;usize, TyKind&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literals-and-the-const-keyword"><a class="header" href="#literals-and-the-const-keyword">Literals and the <code>const</code> keyword</a></h1>
<p>We want to be able to support a few things:</p>
<ul>
<li>writing numbers that will act as field elements directly in the code</li>
<li>writing numbers that will act as relatively small numbers (for indexing into arrays for example) in the code</li>
<li>writing functions that will accept constant arguments. For example to index into an array.</li>
</ul>
<p>The first two points allow us to write things like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3;
assert_eq(y[5], 4);
<span class="boring">}</span></code></pre></pre>
<p>The third point allows us to write things like that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn House.get(self, room: Field) -&gt; Field {
    return House.rooms[room];
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>House</code> takes a <code>Field</code> here, it can in theory be used with anything during type checking.</p>
<p>This is bad. There are two solutions:</p>
<ol>
<li>During type checking, when we realize that <code>room</code> is used to index into an array, we enforce that it must be a constant value during compilation.</li>
<li>We create a distinct type for constants and literals.</li>
</ol>
<p>Approach 1. is not elegant, because it means that it is not clear from the signature of the function alone that the <code>room</code> argument must be a constant.
The user of the function will only get warned when trying to compile the program.</p>
<p>Approach 2. is interesting, because we already have such a type internally to track literals: a <code>BigInt</code>.
The name is a bit misleading in the case of array accesses, because we additionally enforce that it is NOT a big integer, but rather a 32-bit integer (<code>u32</code> in Rust).</p>
<h2 id="implementing-a-literal-type"><a class="header" href="#implementing-a-literal-type">Implementing a literal type</a></h2>
<p>Approach 2 can be implemented in two ways:</p>
<p>a. Use a brand new type, like <code>BigInt</code> for literals.
b. Use a <code>const</code> attribute to indicate that it is a constant.</p>
<p>Approach a. is a bit clumsy in my opinion because the developer need to remember about a new type name, and understand the distinction with that and <code>Field</code>.</p>
<p>On the other hand, approach b. uses the <code>const</code> keyword which is already well-known in many compiled programming languages.</p>
<p>What about this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn House.get(self, const room: Field) -&gt; Field {
// versus
fn House.get(self, room: const Field) -&gt; Field {
<span class="boring">}</span></code></pre></pre>
<p>To contrast, the two other existing attributes (<code>pub</code> and <code>mut</code>) are placed in front of the variable names, not the type names.</p>
<p>One could argue that the type is the same, but the variable being passed is a constant, and so it makes more sense to implement the first version.
This is what we do in noname.</p>
<p>At the time of this writing, the <code>const</code> keyword only seem to make sense in a function argument, and so is implemented in the same way as the <code>pub</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AttributeKind {
    Pub,
    Const,
}

pub struct Attribute {
    pub kind: AttributeKind,
    pub span: Span,
}

pub struct FnArg {
    pub name: Ident,
    pub typ: Ty,
    pub attribute: Option&lt;Attribute&gt;,
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>When a function is parsed by the type checker, a <code>const Field</code> is transformed into a <code>BigInt</code>.
And as such, the type checker will be happy with that variable being used to index into an array, or being used by other functions expecting a constant.</p>
<p>What about other types being <code>const</code>?
I don’t think it makes sense for now, as I can only think of array access requiring this.
So we don’t implement it.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="literals.html#admonition-note"></a></p>
</div>
<div>
<p>If we do want to support that one day, we will have to track more than <code>TyKind</code> in the typechecker…
This can be achieved by adding a <code>const</code> field in the <code>TypeInfo</code> structure that tracks type-related data on noname variables present in the scope.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<h2 id="field-accesses"><a class="header" href="#field-accesses">Field accesses</a></h2>
<p>A field access is an access to a field of a structure, by writing <code>struct.field</code>.
It is represented as an expression in noname:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExprKind {
    // ...
    FieldAccess { lhs: Box&lt;Expr&gt;, rhs: Ident }
<span class="boring">}</span></code></pre></pre>
<p>The reason why the left-hand side is also an expression, as opposed to just a variable pointing to a struct, is that we need to support code like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = b.c.d;
let e = f[3].g;
<span class="boring">}</span></code></pre></pre>
<p>Note that there are other usecases that are not allowed at the moment for readability reasons.
For example we could have allowed the following to be valid noname:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res = some_function().some_field;
<span class="boring">}</span></code></pre></pre>
<p>but instead we require developers to write their logic in the following way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let temp = some_function();
let res = temp.some_field;
<span class="boring">}</span></code></pre></pre>
<p>In the example</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = b.c.d;
<span class="boring">}</span></code></pre></pre>
<p>the expression node representing the right hand side could be seen as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExprKind::FieldAccess {
    lhs: Expr { kind: ExprKind::FieldAccess { // x.y
        lhs: Expr { kind: ExprKind::Variable { name: "x" } },
        rhs: Ident { value: "y" },
    },
    rhs: Ident { value: "z" }, ///  [x.y].z
}
<span class="boring">}</span></code></pre></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Imagine that we want to mutate a variable.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.y.z = 42;
x[4] = 25;
<span class="boring">}</span></code></pre></pre>
<p>At some point the <a href="">circuit-writer</a> would have to go through an expression node looking like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ExprKind::Assignment {
    lhs: /* the left hand side as an Expr */,
    rhs: Expr { kind: ExprKind::BigInt { value: 42 } },
}
<span class="boring">}</span></code></pre></pre>
<p>At this point, the problem is that to go through each expression node, we use the following API, which only gets us a <code>Var</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_expr(
    &amp;mut self,
    global_env: &amp;GlobalEnv,
    fn_env: &amp;mut FnEnv,
    expr: &amp;Expr,
) -&gt; Result&lt;Option&lt;Var&gt;&gt; {
<span class="boring">}</span></code></pre></pre>
<p>So parsing the <code>x.y</code> node would return a variable that either represents <code>x</code> or represents <code>y</code>.
The parent call would then use the result to produce <code>x.y.z</code> with a similar outcome.
Then, we would either have <code>x</code> or <code>z</code> (depending on the strategy we chose) when we reach the assignment expression node.
Not leaving us enough information to modify the variables of <code>x</code> in our <a href="">local function environment</a>.</p>
<p>What we really need when we reach the assignment node is the following:</p>
<ul>
<li>the name of the variable being modified (in both cases <code>x</code>)</li>
<li>if the variable is mutable or not (it was defined with the <code>mut</code> keyword)</li>
<li>the range of circuit variables in the <code>Var.cvars</code> of <code>x</code>, that the <code>x.y.z</code> field access, or the <code>x[42]</code> array access, represents.</li>
</ul>
<h3 id="circuit-writer"><a class="header" href="#circuit-writer">Circuit writer</a></h3>
<p>To implement this in the circuit writer, we follow a common practice of tracking <strong>references</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Represents a variable in the circuit, or a reference to one.
/// Note that mutable variables are always passed as references,
/// as one needs to have access to the variable name to be able to reassign it in the environment.
pub enum VarOrRef {
    /// A [Var].
    Var(Var),

    /// A reference to a noname variable in the environment.
    /// Potentially narrowing it down to a range of cells in that variable.
    /// For example, `x[2]` would be represented with "x" and the range `(2, 1)`,
    /// if `x` is an array of `Field` elements.
    Ref {
        var_name: String,
        start: usize,
        len: usize,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>and we modify the <a href="">circuit-writer</a> to always return a <a href=""><code>VarOrRef</code></a> when processing an expression node in the AST.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="expressions.html#admonition-note"></a></p>
</div>
<div>
<p>While the type checker already checks if the <code>lhs</code> variable is mutable when it encounters an assignment expression,
the circuit-writer should do its best to pass references only when a variable is known to be mutable.
This way, if there is a bug in the type checker, this will turn unsafe code into a runtime error.</p>
</div>
</div>
<p>An array access, or a field access in a struct, is processed as a narrowing of the range we’re referencing in the original variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl VarOrRef {
    fn narrow(&amp;self, start: usize, len: usize) -&gt; Self {
        match self {
            VarOrRef::Var(var) =&gt; {
                let cvars = var.range(start, len).to_vec();
                VarOrRef::Var(Var::new(cvars, var.span))
            }

            //      old_start
            //      |
            //      v
            // |----[-----------]-----| &lt;-- var.cvars
            //       &lt;---------&gt;
            //         old_len
            //
            //
            //          start
            //          |
            //          v
            //      |---[-----]-|
            //           &lt;---&gt;
            //            len
            //
            VarOrRef::Ref {
                var_name,
                start: old_start,
                len: old_len,
            } =&gt; {
                // ensure that the new range is contained in the older range
                assert!(start &lt; *old_len); // lower bound
                assert!(start + len &lt; *old_len); // upper bound
                assert!(len &gt; 0); // empty range not allowed

                Self::Ref {
                    var_name: var_name.clone(),
                    start: old_start + start,
                    len,
                }
            }
        }
    }
<span class="boring">}</span></code></pre></pre>
<h3 id="type-checker-1"><a class="header" href="#type-checker-1">Type checker</a></h3>
<p>While the type checker does not care about the range within a variable, it also needs to figure out if a variable is mutable or not.</p>
<p>That information is in two places:</p>
<ol>
<li>it is stored under the variable’s name in the local environment</li>
<li>it is also known when we look up a variable, and we can thus bubble it up to the parent expression nodes</li>
</ol>
<p>Implementing solution 1. means bubbling up the variable name, in addition to the type, associated to an expression node.</p>
<p>Implementing solution 2. means bubbling up the mutability instead.</p>
<p>As it is possible that we might want to retrieve additional information in the future, we chose to implement solution 1. and carry the variable name in addition to type information when parsing the AST in the type checker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>In noname, the concept of a module is basically a file. A project either is a binary (<code>main.no</code>) or a library (<code>lib.no</code>). That’s it.</p>
<p>A binary or a library can use other libraries by importing them. To do that, a binary or library’s manifest file <code>Noname.toml</code> must contain a <code>dependencies</code> key listing all the other libraries as Github handles like <code>user/repo</code> (e.g. <code>mimoo/sudoku</code>).
Libraries will then be retrieved from Github.</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="modules.html#admonition-note"></a></p>
</div>
<div>
<p>Currently there is no versioning. Not because it’s not important, but because I haven’t had the time to implement it.</p>
</div>
</div>
<p>Each library can be imported in code with the following command:</p>
<pre><code>use module::lib;
</code></pre>
<p>For example, currently you automatically have access to the <code>std</code> module:</p>
<pre><code>use std::crypto;

fn main(pub digest: [Field; 2]) {
    let expected_digest = crypto::poseidon([1, 2]);
    assert_eq(expected_digest, digest);
}
</code></pre>
<p>Each library is seen as a module, and different modules might have the same name:</p>
<pre><code>use a::some_lib;
use b::some_lib;
</code></pre>
<p>There is currently no solution to this problem.</p>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="modules.html#admonition-note-1"></a></p>
</div>
<div>
<p>This is a problem that does not exist in Rust, as there’s a single namespace that everyone shares, but that exists in Golang.
The current proposed solution is to introduce an <code>as</code> keyword, like in Rust, to be able to alias imports (e.g. <code>use a::some_lib as a_some_lib;</code>).</p>
</div>
</div>
<h2 id="dependency-graph-and-type-checking"><a class="header" href="#dependency-graph-and-type-checking">Dependency graph and type checking</a></h2>
<p>During building, a dependency graph of all dependencies is formed (and dependencies are retrieved from Github at the same time). This must be done to detect <a href="https://en.wikipedia.org/wiki/Circular_dependency">dependency cyles</a>.</p>
<p>Once this is done, a list of dependencies from leaves to roots is computed, and each dependency is analyzed in this order.
Dependencies are not compiled! As the circuit-writer is not ran. Things stop at the type checker.
For every new dependency analyzed, all TAST (typed AST) previously computed on previous dependencies are passed as argument.
This way, if a dependency A uses a dependency B, it has access to the TAST of B to perform type checking correctly.</p>
<p>As such, it is important that <code>a::some_lib</code> and <code>b::some_lib</code> are seen as two independent modules.
For this reason, we store imported modules as their fully qualified path, in the set of TASTs that we pass to the type checker.
But in the current module, we store them as their alias, so that we can use them in the code.</p>
<pre><code>TASTs: HashMap&lt;a::some_lib, TAST&gt;
TAST: contains &lt;some_lib -&gt; a::some_lib&gt;
</code></pre>
<h2 id="compilation-and-circuit-generation"><a class="header" href="#compilation-and-circuit-generation">Compilation and circuit generation</a></h2>
<p>Once type checking is done, the circuit writer is given access to all of the dependencies’ TAST (which also contain their AST).
This way, it can jump from AST to AST to generate an unrolled circuit.</p>
<h2 id="another-solution"><a class="header" href="#another-solution">Another solution</a></h2>
<p>This is a bit annoying. We need a context switcher in both the constraint writer and the type checker, and it’s almost the same code.</p>
<h3 id="type-checker-2"><a class="header" href="#type-checker-2">Type Checker</a></h3>
<h3 id="constraint-writer"><a class="header" href="#constraint-writer">Constraint Writer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CircuitWriter {
    /// The type checker state for the main module.
    // Important: this field must not be used directly.
    // This is because, depending on the value of [current_module],
    // the type checker state might be this one, or one of the ones in [dependencies].
    typed: TypeChecker,

    /// The type checker state and source for the dependencies.
    // TODO: perhaps merge {source, typed} in this type?
    dependencies: Dependencies,

    /// The current module. If not set, the main module.
    // Note: this can be an alias that came from a 3rd party library.
    // For example, a 3rd party library might have written `use a::b as c;`.
    // For this reason we must store this as a fully-qualified module.
    pub(crate) current_module: Option&lt;UserRepo&gt;,
<span class="boring">}</span></code></pre></pre>
<p>and then access to the TAST is gated so we can switch context on demand, or figure out what’s the current context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CircuitWriter {
    /// Retrieves the type checker associated to the current module being parsed.
    /// It is possible, when we jump to third-party libraries' code,
    /// that we need access to their type checker state instead of the main module one.
    pub fn current_type_checker(&amp;self) -&gt; &amp;TypeChecker {
        if let Some(current_module) = &amp;self.current_module {
            self.dependencies
                .get_type_checker(current_module)
                .expect(&amp;format!(
                    "bug in the compiler: couldn't find current module: {:?}",
                    current_module
                ))
        } else {
            &amp;self.typed
        }
    }

    pub fn expr_type(&amp;self, expr: &amp;Expr) -&gt; Option&lt;&amp;TyKind&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.node_types.get(&amp;expr.node_id)
    }

    pub fn node_type(&amp;self, node_id: usize) -&gt; Option&lt;&amp;TyKind&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.node_types.get(&amp;node_id)
    }

    pub fn struct_info(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;StructInfo&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.struct_info(name)
    }

    pub fn fn_info(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;FnInfo&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.functions.get(name)
    }

    pub fn size_of(&amp;self, typ: &amp;TyKind) -&gt; Result&lt;usize&gt; {
        let curr_type_checker = self.current_type_checker();
        curr_type_checker.size_of(&amp;self.dependencies, typ)
    }

    pub fn resolve_module(&amp;self, module: &amp;Ident) -&gt; Result&lt;&amp;UsePath&gt; {
        let curr_type_checker = self.current_type_checker();

        let res = curr_type_checker.modules.get(&amp;module.value).ok_or_else(|| {
            self.error(
                ErrorKind::UndefinedModule(module.value.clone()),
                module.span,
            )
        });

        res
    }

    pub fn do_in_submodule&lt;T, F&gt;(&amp;mut self, module: &amp;Option&lt;Ident&gt;, mut closure: F) -&gt; Result&lt;T&gt;
    where
        F: FnMut(&amp;mut CircuitWriter) -&gt; Result&lt;T&gt;,
    {
        if let Some(module) = module {
            let prev_current_module = self.current_module.clone();
            let submodule = self.resolve_module(module)?;
            self.current_module = Some(submodule.into());
            let res = closure(self);
            self.current_module = prev_current_module;
            res
        } else {
            closure(self)
        }
    }

    pub fn get_fn(&amp;self, module: &amp;Option&lt;Ident&gt;, fn_name: &amp;Ident) -&gt; Result&lt;FnInfo&gt; {
        if let Some(module) = module {
            // we may be parsing a function from a 3rd-party library
            // which might also come from another 3rd-party library
            let module = self.resolve_module(module)?;
            self.dependencies.get_fn(module, fn_name) // TODO: add source
        } else {
            let curr_type_checker = self.current_type_checker();
            let fn_info = curr_type_checker
                .functions
                .get(&amp;fn_name.value)
                .cloned()
                .ok_or_else(|| {
                    self.error(
                        ErrorKind::UndefinedFunction(fn_name.value.clone()),
                        fn_name.span,
                    )
                })?;
            Ok(fn_info)
        }
    }

    pub fn get_struct(&amp;self, module: &amp;Option&lt;Ident&gt;, struct_name: &amp;Ident) -&gt; Result&lt;StructInfo&gt; {
        if let Some(module) = module {
            // we may be parsing a struct from a 3rd-party library
            // which might also come from another 3rd-party library
            let module = self.resolve_module(module)?;
            self.dependencies.get_struct(module, struct_name) // TODO: add source
        } else {
            let curr_type_checker = self.current_type_checker();
            let struct_info = curr_type_checker
                .struct_info(&amp;struct_name.value)
                .ok_or(self.error(
                    ErrorKind::UndefinedStruct(struct_name.value.clone()),
                    struct_name.span,
                ))?
                .clone();
            Ok(struct_info)
        }
    }

    pub fn get_source(&amp;self, module: &amp;Option&lt;UserRepo&gt;) -&gt; &amp;str {
        if let Some(module) = module {
            &amp;self
                .dependencies
                .get_type_checker(module)
                .expect(&amp;format!(
                    "type checker bug: can't find current module's (`{module:?}`) file"
                ))
                .src
        } else {
            &amp;self.typed.src
        }
    }

    pub fn get_file(&amp;self, module: &amp;Option&lt;UserRepo&gt;) -&gt; &amp;str {
        if let Some(module) = module {
            &amp;self.dependencies.get_file(module).expect(&amp;format!(
                "type checker bug: can't find current module's (`{module:?}`) file"
            ))
        } else {
            &amp;self.typed.filename
        }
    }

    pub fn get_current_source(&amp;self) -&gt; &amp;str {
        self.get_source(&amp;self.current_module)
    }

    pub fn get_current_file(&amp;self) -&gt; &amp;str {
        self.get_file(&amp;self.current_module)
    }

    pub fn add_local_var(&amp;self, fn_env: &amp;mut FnEnv, var_name: String, var_info: VarInfo) {
        // check for consts first
        let type_checker = self.current_type_checker();
        if let Some(_cst_info) = type_checker.constants.get(&amp;var_name) {
            panic!(
                "type checker bug: we already have a constant with the same name (`{var_name}`)!"
            );
        }

        //
        fn_env.add_local_var(var_name, var_info)
    }

    pub fn get_local_var(&amp;self, fn_env: &amp;FnEnv, var_name: &amp;str) -&gt; VarInfo {
        // check for consts first
        let type_checker = self.current_type_checker();
        if let Some(cst_info) = type_checker.constants.get(var_name) {
            let var = Var::new_constant(cst_info.value, cst_info.typ.span);
            return VarInfo::new(var, false, Some(TyKind::Field));
        }

        // then check for local variables
        fn_env.get_local_var(var_name)
    }
<span class="boring">}</span></code></pre></pre>
<p>we basically have to implement the same in the type checker… It always sort of looks the same. A handy function is either called with <code>get_fn</code> or <code>expr_type</code> or <code>node_type</code> etc. or we call a block of code with <code>do_in_submodule</code>.</p>
<p>all of these basically start by figuring out the <code>curr_type_checker</code>:</p>
<ul>
<li>what’s the current module (<code>self.current_module</code>)?
<ul>
<li>if there is none, use the main TAST (<code>self.typed</code>)</li>
<li>otherwise find that TAST (in <code>self.dependencies</code>)</li>
<li>btw all of this logic is implemented in <code>self.current_type_checker()</code></li>
<li>the returned TAST is called <code>curr_type_checker</code></li>
</ul>
</li>
</ul>
<p>then, if we’re handling something that has a module:</p>
<ul>
<li>do name resolution (implemented in <code>resolve_module()</code>):
<ul>
<li>use <code>curr_type_checker</code> to resolve the fully-qualified module name</li>
</ul>
</li>
</ul>
<p>or if we’re executing a block within a module:</p>
<ul>
<li>save the current module (<code>self.current_module</code>)</li>
<li>replace it with the module we’re using (we have used <code>resolve_module()</code> at this point)</li>
<li>execute in the closure where <code>self</code> is passed</li>
<li>when we return, reset the current module to its previous saved state</li>
</ul>
<p>note that when we return an error, we always try to figure out which file it came from, which can be resolved via <code>self.current_module</code>.</p>
<h2 id="name-resolution-approach"><a class="header" href="#name-resolution-approach">Name resolution approach</a></h2>
<p>If we have a name resolution phase, we could do this:</p>
<ul>
<li>fully qualify all things that need to be fully qualified: structs, functions, methods (which are defined as function currently, should we not do that?), consts. And that’s it?</li>
<li>create a <code>Hashmap&lt;usize, String&gt;</code> to store all the filenames</li>
<li>add the <code>usize</code> in all <code>Span</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cellvar"><a class="header" href="#cellvar">CellVar</a></h1>
<p>A <a href="https://mimoo.github.io/noname/rustdoc/var/struct.CellVar.html"><code>CellVar</code></a> type is a type that represents an internal variable. Importantly, it is named after the fact that it relates to a specific cell, or even multiple cells if they will have the same value (using some wiring), in the execution trace.</p>
<p>A <code>CellVar</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CellVar {
    index: usize,
    span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>It is tracked using a <code>usize</code>, which is just a counter that the compiler increments every time a new <code>CellVar</code> is created.</p>
<p>A <code>CellVar</code> is created via the <code>new_internal_var</code> function which does two things: increments the variable counter, and stores some information on how to compute it (which will be useful during witness generation)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new_internal_var(&amp;mut self, val: Value, span: Span) -&gt; CellVar {
    // create new var
    let var = CellVar::new(self.next_variable, span);
    self.next_variable += 1;

    // store it in the compiler
    self.vars_to_value.insert(var, val);

    var
}
<span class="boring">}</span></code></pre></pre>
<p>a <code>Value</code> tells us how to compute the <code>CellVar</code> during witness generation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Value {
    /// Either it's a hint and can be computed from the outside.
    Hint(Box&lt;dyn Fn(&amp;Compiler, &amp;mut WitnessEnv) -&gt; Result&lt;Field&gt;&gt;),

    /// Or it's a constant (for example, I wrote `2` in the code).
    Constant(Field),

    /// Or it's a linear combination of internal circuit variables (+ a constant).
    LinearCombination(Vec&lt;(Field, CellVar)&gt;, Field),

    /// A public or private input to the function
    /// There's an index associated to a variable name, as the variable could be composed of several field elements.
    External(String, usize),

    /// A public output.
    /// This is tracked separately as public inputs as it needs to be computed later.
    PublicOutput(Option&lt;CellVar&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>Note: a <code>CellVar</code> is potentially not directly added to the rows of the execution trace.
For example, a private input is converted directly to a (number of) <code>CellVar</code>(s),
but only added to the rows when it appears in a constraint for the first time.</p>
<p>As the final step of the compilation, we double check that all <code>CellVar</code>s have appeared in the rows of the execution trace at some point. If they haven’t, it can mean two things:</p>
<ul>
<li>A private or public input was never used in the circuit. In this case we return an error to the user.</li>
<li>There is a bug in the compiler. In this case we panic.</li>
</ul>
<p>TODO: explain the LinearCombination. I think we only need an <code>Add((Field, Var), (Field, Var), Field)</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vars"><a class="header" href="#vars">Vars</a></h1>
<p>We already have <a href="./cellvar.html"><code>CellVar</code></a>s, why have <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a>s?
The distinction is a matter of abstraction:</p>
<ul>
<li><code>CellVar</code>s are low-level: they track actual cells of the execution trace. When a single <code>CellVar</code> is assigned to multiple cells the wiring must make sure the cells are wired (so that they can only have the same value).</li>
<li><code>Var</code>s are a higher-level concept: they track variables that are created in the noname language either directly (e.g. <code>let x = 3</code>) or indirectly (e.g. in <code>x + (y + z)</code> the term <code>y + z</code> is stored under an anonymous <code>Var</code>)</li>
</ul>
<p>While a <code>CellVar</code> represents a single field element, a <code>Var</code> can potentially represent several field elements (and as such several cells in the execution trace).
Here are some examples of <code>Var</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a constant
let x = 5;

// a field element that will be computed at runtime
let y = private_input + 1;

// a builtin type, like an array, or a bool
let z = [y, x, 6];

// or a custom type
let s = Thing { x, y };
<span class="boring">}</span></code></pre></pre>
<p>Internally, a <a href="https://mimoo.github.io/noname/rustdoc/var/struct.Var.html"><code>Var</code></a> is represented as such:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A constant value created in a noname program
pub struct Constant {
    /// The actual value.
    pub value: Field,

    /// The span that created the constant.
    pub span: Span,
}

/// Represents a cell in the execution trace.
pub enum ConstOrCell {
    /// A constant value.
    Const(Constant),

    /// A cell in the execution trace.
    Cell(CellVar),
}

/// A variable in a program can have different shapes.
pub enum VarKind {
    /// We pack [Const] and [CellVar] in the same enum because we often branch on these.
    ConstOrCell(ConstOrCell),

    /// A struct is represented as a mapping between field names and other [VarKind]s.
    Struct(HashMap&lt;String, VarKind&gt;),

    /// An array or a tuple is represetend as a list of other [VarKind]s.
    ArrayOrTuple(Vec&lt;VarKind&gt;),
}

/// Represents a variable in the noname language, or an anonymous variable during computation of expressions.
pub struct Var {
    /// The type of variable.
    pub kind: VarKind,

    /// The span that created the variable.
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="var.html#admonition-note"></a></p>
</div>
<div>
<p>Note: see the <a href="./constants.html">Constant chapter</a> to see why constants are treated differently.</p>
</div>
</div>
<h2 id="anonymous-variable"><a class="header" href="#anonymous-variable">Anonymous variable</a></h2>
<p>Here’s a short note on anonymous variable.</p>
<p>When circuit writer parses the <a href="./compilation.html">ast</a>, it will convert each expression into a <code>Var</code> (unless the expression does not compute to an actual value).</p>
<p>In our example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = t + (z + y);
<span class="boring">}</span></code></pre></pre>
<p>the <code>z + y</code> is parsed as an expression (a binary operation involving <code>z</code> and <code>y</code>) and stored under a var <code>var1</code>.
Then <code>t + ...</code> is also parsed as another binary operation expression and stored under another var <code>var2</code>.
Finally the <code>let x = ...</code> is parsed as an assignment statement, and <code>x</code> is stored as a local variable associated to the right handside var <code>var2</code>.</p>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="var.html#admonition-note-1"></a></p>
</div>
<div>
<p>See the <a href="./scope.html">Scope chapter</a> for more information on local variables.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-1"><a class="header" href="#constants-1">Constants</a></h1>
<p>Developers write constants in their code all the time. For example, the following code has two constants <code>2</code> and <code>4</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2 + y;
assert_eq(x, 4);
<span class="boring">}</span></code></pre></pre>
<p>It is important that constants are tracked differently than <code>CellVar</code>s for several reasons:</p>
<ul>
<li>It is sometimes useless to constrain them directly. For example, in <code>let x = 3 + 7;</code> you can see that we should not constrain <code>3</code> and <code>7</code> separately, but rather the result <code>10</code>.</li>
<li>It is sometimes useless to constrain them at all. For example, boolean constants are never constrained because you never need to.</li>
<li>They can be cached to avoid creating several constraints for the same constant.</li>
</ul>
<p>Currently a constant appears in the circuit only when <code>CircuitWriter::add_constant</code> is called.
It uses the generic gate to constrain the value, and is not cached (so calling it several times with the same constant will create multiple constraints):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_constant(&amp;mut self, value: Field, span: Span) -&gt; CellVar {
    let var = self.new_internal_var(Value::Constant(value), span);

    let zero = Field::zero();
    self.add_gate(
        GateKind::DoubleGeneric,
        vec![Some(var)],
        vec![Field::one(), zero, zero, zero, value.neg()],
        span,
    );

    var
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the <code>Value</code> keep track of the constant as well.</p>
<p>Warning: gadgets must all handle constants gracefully.
That is, they must constrain constants themselves (by calling <code>CircuitWriter::add_constant</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-environment"><a class="header" href="#global-environment">Global environment</a></h1>
<p>In this chapter we will talk about functions.</p>
<h2 id="local-functions"><a class="header" href="#local-functions">Local functions</a></h2>
<p>Third-party libraries can have function names that collide with your own function names.
Due to this, they are tracked in a different data structure that we will see later.</p>
<p>Local functions include:</p>
<ul>
<li><strong>automatically imported built-ins</strong>. Think functions like <code>assert</code> and <code>assert_eq</code>. See <a href="./basics.html#Builtins-and-use-statements">here</a> for a full list.</li>
<li><strong>main</strong>, this is the main function that your program runs. Of course if you’re writing a library this function is not present.</li>
<li><strong>normal functions</strong>, these are functions that you define in your program. They can be recursive.</li>
<li><strong>methods</strong>, these are functions that are defined on a type. They can be recursive as well.</li>
</ul>
<p>Built-ins are different from all other functions listed because they are not written in noname, but written in Rust within the compiler.</p>
<p>For this reason we track functions according to this enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FnKind {
    /// signature of the function
    BuiltIn(FnHandle),

    /// Any function declared in the noname program (including main)
    LocalFn(AST)

    /// path, and signature of the function
    Library(Vec&lt;String&gt;),
}

/// An actual handle to the internal function to call to resolve a built-in function call.
pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub struct FnInfo {
    pub name: Ident,
    pub sig: FnSig,
    pub kind: FnKind,
    pub span: Span,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the signature of a <code>FnHandle</code> is designed to:</p>
<ul>
<li><code>&amp;mut CircuitWriter</code>: take a mutable reference to the circuit writer, this is because built-ins need to be able to register new variables and add gates to the circuit</li>
<li><code>&amp;[Var]</code>: take an unbounded list of variables, this is because built-ins can take any number of arguments, and different built-ins might take different types of arguments</li>
<li><code>Span</code>: take a span to return user-friendly errors</li>
<li><code>-&gt; Result&lt;Option&lt;Var&gt;&gt;</code>: return a <code>Result</code> with an <code>Option</code> of a <code>Var</code>. This is because built-ins can return a variable, or they can return nothing. If they return nothing, then the <code>Option</code> will be <code>None</code>. If they return a variable, then the <code>Option</code> will be <code>Some(Var)</code>.</li>
</ul>
<p>We track all of these functions in the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    functions: HashMap&lt;String, FnInfo&gt;,

    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-builtins"><a class="header" href="#handling-builtins">Handling builtins</a></h2>
<p>Builtins are handled in a special way. They are not written in noname, but in Rust.</p>
<h2 id="handling-local-functions"><a class="header" href="#handling-local-functions">Handling local functions</a></h2>
<p>The parser:</p>
<ul>
<li>saves the AST of each function it encounters. Specifically, the function’s AST is stored under the <code>GlobalEnv</code> (TODO: where exactly?). This is necessary as the circuit writer will have to switch to a function’s AST when a function is called (and then return to its own AST).</li>
</ul>
<p>The first step of the type checker resolves imports by doing the following:</p>
<ul>
<li>store all built-ins in the <code>functions</code> map of the <code>GlobalEnv</code></li>
<li>resolve all imports (e.g. <code>use std::crypto</code>)</li>
<li>type check each function individually, and save their signature in the <code>GlobalEnv</code> using the <code>FnSig</code> type</li>
<li>type check function calls with the signatures they just saved</li>
</ul>
<p>(TODO: this means that function declaration must be ordered. I think it is a GOOD thing)</p>
<p>When a function is called, we do the following:</p>
<ul>
<li>if the function is qualified (e.g. <code>crypto::poseidon</code>), then lookup imported modules (see next section)</li>
<li>otherwise, check if the function exist in the <code>GlobalEnv</code>, if it doesn’t then return an error</li>
<li>if the function exist, then create a new <code>FnEnv</code> and register the arguments as local variables there</li>
<li>switch to the function’s AST and pass the new <code>FnEnv</code> as argument</li>
<li>TODO: how to handle the return value? it should be saved in the <code>FnEnv</code></li>
</ul>
<h2 id="third-party-libraries"><a class="header" href="#third-party-libraries">Third-party libraries</a></h2>
<p>TODO: write this part</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This seems to be used by both the type checker and the AST
// TODO: right now there's only one scope, but if we want to deal with multiple scopes then we'll need to make sure child scopes have access to parent scope, shadowing, etc.
#[derive(Default, Debug)]
pub struct GlobalEnv {
    /// the functions present in the scope
    /// contains at least the set of builtin functions (like assert_eq)
    pub functions: HashMap&lt;String, FuncInScope&gt;,

    /// stores the imported modules
    pub modules: HashMap&lt;String, ImportedModule&gt;,

    /// the arguments expected by main
    pub main_args: (HashMap&lt;String, FuncArg&gt;, Span),
}

pub type FnHandle = fn(&amp;mut CircuitWriter, &amp;[Var], Span) -&gt; Result&lt;Option&lt;Var&gt;&gt;;

pub enum FuncInScope {
    /// signature of the function
    BuiltIn(FnSig, FnHandle),

    /// path, and signature of the function
    Library(Vec&lt;String&gt;, FnSig),
}
<span class="boring">}</span></code></pre></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="functions.html#admonition-note"></a></p>
</div>
<div>
<p>Not all modules are third-party libraries, some are also built-ins (e.g. <code>std::crypto</code>).</p>
</div>
</div>
<p>As part of resolving imports, the type checker looks at third-party libraries differently…</p>
<p>TODO: implement this</p>
<p>TODO: how to handle diamond dependency graph or cycles? We must form a dependency graph first, and resolve dependency according to this graph</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-1"><a class="header" href="#scope-1">Scope</a></h1>
<p>Like most languages, noname has a notion of scope within a function.
Unlike a lot of languages noname forbids shadowing at all scope level.
This means that eventhough different functions can use local variable with colliding names, the local variable of one function must all have different names.</p>
<p>For example, the following code does not compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
let x = 3; // this won't compile

let y = 4;
for i in 0..4 {
    let y = i; // this won't compile either
}
<span class="boring">}</span></code></pre></pre>
<p>Scopes are only used for:</p>
<ul>
<li>for loops</li>
<li>in the future: if/else statements</li>
</ul>
<h2 id="scope-mechanisms"><a class="header" href="#scope-mechanisms">Scope mechanisms</a></h2>
<p>Both the type checker and the circuit writer need to keep track of local variable.
For the type checker (<code>type_checker.rs</code>), a <code>TypeEnv</code> structure keeps track of the association between all local variables names and their type information.
For the circuit writer (<code>circuit_writer.rs</code>), a <code>FnEnv</code> structure keeps track of the association between all local variable names and their circuit variable.</p>
<p>Both structure also keep track of how nested the current block is (the top level starting at level 0).
For this reason, it is important to remember to increase the current scope when entering a new block (for loop, if statement, etc.) and to decrease it when exiting the block.
In addition, all variables from a scope must be disabled (but not deleted, in order to detect shadowing) when exiting that scope.</p>
<p>For example, the type checker’s <code>TypeEnv</code> structure implements the following logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TypeEnv {
    // ...


    /// Enters a scoped block.
    pub fn nest(&amp;mut self) {
        self.current_scope += 1;
    }

    /// Exits a scoped block.
    pub fn pop(&amp;mut self) {
        self.current_scope.checked_sub(1).expect("scope bug");

        // disable variables as we exit the scope
        for (name, (scope, type_info)) in self.vars.iter_mut() {
            if *scope &gt; self.current_scope {
                type_info.disabled = true;
            }
        }
    }

    /// Returns true if a scope is a prefix of our scope.
    pub fn is_in_scope(&amp;self, prefix_scope: usize) -&gt; bool {
        self.current_scope &gt;= prefix_scope
    }

    /// Stores type information about a local variable.
    /// Note that we forbid shadowing at all scopes.
    pub fn store_type(&amp;mut self, ident: String, type_info: TypeInfo) -&gt; Result&lt;()&gt; {
        match self
            .vars
            .insert(ident.clone(), (self.current_scope, type_info.clone()))
        {
            Some(_) =&gt; Err(Error::new(
                 ErrorKind::DuplicateDefinition(ident),
                 type_info.span,
            )),
            None =&gt; Ok(()),
        }
    }

    /// Retrieves type information on a variable, given a name.
    /// If the variable is not in scope, return false.
    pub fn get_type_info(&amp;self, ident: &amp;str) -&gt; Option&lt;TypeInfo&gt; {
        if let Some((scope, type_info)) = self.vars.get(ident) {
            if self.is_in_scope(*scope) &amp;&amp; !type_info.disabled {
                Some(type_info.clone())
            } else {
                None
            }
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-outputs"><a class="header" href="#public-outputs">Public Outputs</a></h1>
<p>Public outputs are usually part of the public inputs in Plonk.</p>
<p>In noname, public outputs are treated differently than the public inputs for one reason: unlike (real) public inputs they cannot be computed directly during witness generation (proving).</p>
<p>This is because public inputs are listed first in the circuit. During witness generation, we go through each rows and evaluate the values of the cells to construct the execution trace.
When we reach the public output part of the public input, we do not yet have enough information to construct the values.
Thus, we ignore them, and fill them later on.</p>
<p>During the compilation, we create <code>CellVars</code> to keep track of the public output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// If a public output is set, this will be used to store its [CircuitVar] (cvar).
    /// The public output generation works as follows:
    /// 1. This cvar is created and inserted in the circuit (gates) during compilation of the public input
    ///    (as the public output is the end of the public input)
    /// 2. When the `return` statement of the circuit is parsed,
    ///    it will set this `public_output` variable again to the correct vars.
    /// 3. During witness generation, the public output computation
    ///    is delayed until the very end.
    pub public_output: Option&lt;CellVars&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>During witness generation (see the <a href="./witness-generation.html">Witness Generation chapter</a>), we indeed defer computation the first time we go through the public output rows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = if let Some(var) = var {
    // if it's a public output, defer it's computation
    if matches!(self.vars_to_value[&amp;var], Value::PublicOutput(_)) {
        public_outputs_vars.push((row, *var));
        Field::zero()
    } else {
        self.compute_var(&amp;mut env, *var)?
    }
} else {
    Field::zero()
};
witness_row[col] = val;
<span class="boring">}</span></code></pre></pre>
<p>and at the end we go back to them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// compute public output at last
let mut public_output = vec![];

for (row, var) in public_outputs_vars {
    let val = self.compute_var(&amp;mut env, var)?;
    witness[row][0] = val;
    public_output.push(val);
}
<span class="boring">}</span></code></pre></pre>
<p>and finally we return the public output to the prover so that they can send it to the verifier, as well as the “full public input” which is the concatenation of the public input and the public output (needed to finalized the proof):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// return the public output separately as well
Ok((Witness(witness), full_public_inputs, public_output))
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witness-generation"><a class="header" href="#witness-generation">Witness Generation</a></h1>
<p>Witness generation is the process of creating the execution trace table during proving.
The execution trace table is then passed to the <a href="">kimchi</a> proof system which will create the final proof.</p>
<p>The code creates a series of instructions during compilation for the witness generation to follow.
These instructions are stored as two different fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Compiler {
    // ...

    /// This is how you compute the value of each variable, for witness generation.
    pub vars_to_value: HashMap&lt;CellVar, Value&gt;,

    // ...

    /// This is used to compute the witness row by row.
    pub witness_table: Vec&lt;Vec&lt;Option&lt;CellVar&gt;&gt;&gt;,

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>witness_table</code> can essentially be seen as the execution trace table, containing variables instead of values.</p>
<p>The witness generation goes as follows:</p>
<ol>
<li>Each rows in <code>witness_table</code> is looked at one by one</li>
<li>For each <code>CellVar</code> in the row:
<ol>
<li>If it is set, it is evaluated using the <code>Value</code> stored in <code>vars_to_value</code>.</li>
<li>If it set to <code>None</code>, it is simply evaluated as <code>0</code>.</li>
</ol>
</li>
<li>Once the row is created, it is checked for correctness by checking what gate was used in the row. Note that this is only true for the generic gate, as we trust built-in gadgets to produce correct values. For example, <code>assert(x, 2)</code> will be checked because it is using the generic gate, but <code>let y = poseidon(x)</code> won’t be because we trust the poseidon gate to be correct (and if there is a bug there, kimchi will still catch it).</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
